[' Chase game\n\nIn this tutorial we will make a game where you control a bird that\nchases a star around the stage.\n\nIn this project you will learn about making multiple Sprites, making\nthem move, and detecting when they come close together.\n\n---\n\n', ' Setting up Pytch\n\nAs usual we have to make sure the Pytch add-ons are available. This\nmeans writing an "import" line at the top of our program.\n\nimport pytch\n\n\n', ' Setting up the stage\n\nLet\'s start by setting up the stage for the game. There is a nice\nbackdrop of some clouds so we define a _Stage_ that will look good\nwhen the bird is flying around.\n\nMaking a Stage in Pytch is rather like making a Sprite, we have to\ncreate a new "class" that says it is a Stage. Then we can define\n_backdrops_ as part of that stage.\n\nYou can only have one class in your project for the Stage (there\'s\nonly one stage, no matter how many Sprites there are), but it can have\ndifferent backdrops if you need that. This project will only have one,\nso Pytch will automatically select it when the project starts.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nYou can try the project now — click the *green flag* to run your\nprogram — and you should see the clouds as a nice backdrop.\n\n\n', ' Making the Bird character\n\nNext we will make the bird character that the player will control. The\nfirst step is to make a new Sprite and give it a costume. The costume\nwe are using is already in the project assets so we just need to make\nsure Pytch knows which costume is for this Sprite.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n\n\n', ' Moving the bird to its starting position\n\nThe game will start when the player presses the green flag. As soon as\nthat happens I want the bird to move right to the middle of the\nstage. So I *def*ine a new bit of code that will run when when the\ngreen flag is clicked. I\'m going to name this "start", but the name\nisn\'t really important, it\'s the hat block that controls when this\nwill be run.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n\n\nIf you try this code now — click the green flag to run your program —\nyou will see that the bird costume is actually rather too big for the\nstage. I can fix this by telling the sprite to pick a smaller size\nbefore it appears, using the `set_size` command. The number given to\n`set_size` controls the size, from 1 (full size) to 0 (so small you\ncan\'t see it).\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n\n', ' Making the bird move\n\nThe next job is to let the bird move around the stage so that it can\nchase something. I will let the player use the arrow keys to move it\naround.\n\nBefore I do that I am going to set up a variable that I will use to\ncontrol the speed the bird moves at. I don\'t _have_ to set my project\nup this way but it will make it easier to change how fast the bird\nmoves if I want to.\n\nI create a variable in the Bird by adding this line after the costumes:\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n\nNow I will make some code to move the bird to the right. Once this is\nworking nicely we can copy it to move in the other directions. I want\nthis code to run whenever the player presses the right-arrow key, so I\nmake a script (I have to give it a name, Python needs that), and I\nmark it with some code that lets Pytch know this script gets run when\nthe right-arrow key is pressed.\n\nI can make the Bird sprite move using the `change_x` function.  Notice\nhow I\'m using the `speed` variable that\'s defined as part of the Bird\nto say how far the bird will move.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n\nIf you try the project now then you will be able to make the bird move\nin one direction by pressing the right arrow key. Excellent, we are\nwell on the way!\n\nNow we should add three move methods for the other three\ndirections. We can make the bird move to the left by changing the `x`\nvalue in the negative direction (just put a minus sign in front of the\nvariable). To move up and down we change the `y` value of the Sprite.\n\nOne thing to watch out for is that each method needs to have a\ndifferent name, or the later ones replace the earlier ones in the\nSprite (which would mean there is only one of them left, and some\ndirections wouldn\'t work!).\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nIf you try the project out now then you should be able to move the\nbird in all four directions.\n\nIf you think the bird is moving a little slowly then you could try\nchanging the number we store in the `speed` variable. Because each of\nthe moving methods uses the number they will all change `x` or `y` by\nthe amount stored in the variable. Remember, you have to build and run\nthe project after making any changes.\n\n', ' Giving the Bird something to chase\n\nNow that the bird can move around the screen let\'s give it something\nto chase. Make a new Sprite and set its costume to the "star"\nimage.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n\n', ' Moving the Star randomly\n\nWe want the star to move about, but not under the player\'s control\n(that would make it a bit easy to catch!). The plan is to pick a\nlocation on the stage at random and then head towards it for a\nwhile. Once the star gets there we will pick a new location and move\ntowards that, and keep this up until the Bird catches it.\n\nTo start with we want to appear on the stage a little bit away from\nthe Bird. The star costume is also kind of big so I\'ll set the size at\nthe same time. This should all happen when the green flag is clicked.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n\n\nI can have the star keep moving as long as the game is running, just\nmoving from place to place. When it gets caught we can hide it for a\nwhile and then have it reappear at whatever position it\'s randomly\nmoved to so that the bird can continue to chase it.\n\nTo make some code that repeats I can use the Python `while` command. A\n`while` loop has something it checks each time, and it will repeat its\ncode as long as that thing is true. Normally you put something that\ncould be different each time it\'s checked (for example, something that\nchecks the `x` position of a Sprite) but if you want the code to\nrepeat forever you can just write `True` there and it will always be\ntrue!\n\nNotice the `:` at the end of the line. Like classes and script\ndefinitions, this loop will have more commands inside it (which will\nbe the stuff to be repeated over and over).  For now, we\'ll just make\nsure the Star is visible, because we know that our program soon will\nhide the Star when it gets caught, and we want to make sure it\'s\nvisible at the start of each movement across the stage.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n\n\nNow I want to pick a random location on the stage. Python has a way to\nmake random numbers, so if I just pick two `x` and `y` numbers they\ncan be the destination for the star to move towards. When the star\ngets there the loop will repeat and a new destination will be chosen.\n\nThe `random.randint()` function in Python selects a random number\nbetween two points (so `random.randint(10, 20)` will pick a number\nbetween 10 and 20). The Pytch Stage has x coordinates from -240 to\n+240, so we\'ll choose a random number in that range for `x`.  This\nwill allow the Star to stick out beyond the edge of the stage\nslightly, but that\'s OK.  And we\'ll do a similar thing for `y`, which\nwe\'ll choose between -180 and +180.\n\nUsing this I set up two variables inside the loop:\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n\n\nNext I want to move the star to that point. But I don\'t want to just\nhave it hop there, because that will mean the star jumping around the\nstage as fast as possible. It will just flicker around and the Bird\nwon\'t have any chance to catch it. Instead I want it to move smoothly\nto the point over a few seconds.\n\nScratch has a handy block called "glide to" which does this. Pytch has\nthe same thing, in a method called `glide_to_xy()`.  We\'ll use this,\nasking Pytch to make the Star take 2 seconds to glide to its\ndestination.\n\nimport pytch\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n\nThere is one bit of housekeeping to attend to. The `random` functions\nare not actually built-in to Python, like Pytch they are a kind of\nadd-on (called a "library"). We need to add a line to the top of the\nproject to get them included:\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n\n(This is very similar to how you "add an extension" in Scratch to make\nmore blocks available.)\n\nIf you try the project out now you\'ll see it\'s almost complete! The\nStar glides around and the Bird can chase it. The only thing we need\nto do is have something happen when the bird catches the Star!\n\n', ' Catching the Star\n\nPytch has a method called `touching` that checkes to see if two\nSprites are touching each other.\n\nWe could check this every time the Bird moves to see if it has caught\nup with the Star. But we would also have to check it every time the\nStar moved, in case the bird was standing still and the Star ran into\nit!\n\nInstead I will write a Script that does nothing except continuously\ncheck to see if the Star has collided with the bird. That way no\nmatter which Sprite was moving we will detect it in one bit of\ncode. I\'ll use the same idea that the `play` method had to keep\nchecking.\n\nThis script should start up as soon as the game begins, so I give it\nthe same "green flag" hat as the `start` and `play` methods.\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n    @pytch.when_green_flag_clicked\n    def check_catch(self):\n        while True:\n            if self.touching(Star):\n                self.say_for_seconds("Got you!", 2)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n\nIf you try the project now you\'ll see that this is _almost_ perfect,\nbut there are two problems:\n\n', ' Hiding the star when it\'s caught\n\nAfter the bird catches the star we want the star to vanish for a\ntime. Otherwise after the bird says "Got you" the star will be very\nnearby (maybe even still touching the bird!) and it\'s too easy to\ncatch it.\n\nOne way we could do this is to have the Star also constantly check to\nsee whether it\'s been caught, and hide itself as soon as it\nis. Because the loop in `play` starts with `show` the Star will\nreappear when it has finished gliding to its destination, and the game\ncan continue.\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n    @pytch.when_green_flag_clicked\n    def check_catch(self):\n        while True:\n            if self.touching(Star):\n                self.say_for_seconds("Got you!", 2)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n    @pytch.when_green_flag_clicked\n    def check_caught(self):\n        while True:\n            if self.touching(Bird):\n                self.hide()\n\n\n', ' Fixing a start-up bug\n\nYou might notice that the bird catches the star as soon as we start\nthe program.  This is because the star hasn\'t had a chance to move\nbefore the bird checks whether it\'s caught the star.  We\'ll work round\nthis problem by making the Bird wait for a tiny delay before starting\nchecking for touching the star:\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n    @pytch.when_green_flag_clicked\n    def check_catch(self):\n        pytch.wait_seconds(0.1)\n        while True:\n            if self.touching(Star):\n                self.say_for_seconds("Got you!", 2)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n    @pytch.when_green_flag_clicked\n    def check_caught(self):\n        while True:\n            if self.touching(Bird):\n                self.hide()\n\n\n\n', ' Adding some sound\n\nTo make the game a bit more fun we\'ll have the bird make an excited\nnoise when it catches the Star.\n\nWe can add _sounds_ to a Sprite using the Sounds variable.\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    Sounds = ["honk.wav"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n    @pytch.when_green_flag_clicked\n    def check_catch(self):\n        pytch.wait_seconds(0.1)\n        while True:\n            if self.touching(Star):\n                self.say_for_seconds("Got you!", 2)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n    @pytch.when_green_flag_clicked\n    def check_caught(self):\n        while True:\n            if self.touching(Bird):\n                self.hide()\n\n\nAnd we can add a line to the bird\'s `check_catch` method that plays\nthis sound when the star is caught. The script will go on to the next\ncommand immediately, but because of the `say` command it will wait for\nabout the right amount of time for the sound to finish.\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    Sounds = ["honk.wav"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n    @pytch.when_green_flag_clicked\n    def check_catch(self):\n        pytch.wait_seconds(0.1)\n        while True:\n            if self.touching(Star):\n                self.start_sound("honk")\n                self.say_for_seconds("Got you!", 2)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n    @pytch.when_green_flag_clicked\n    def check_caught(self):\n        while True:\n            if self.touching(Bird):\n                self.hide()\n\n\n\n', " Add instructions\n\nTo tell the player how to use our game, we'll add some instructions at\nthe top of our code.  We'll do this using a Python *comment*, which is\na part of your program meant just for human readers — Python ignores\nit.  In Python, a line starting with the `", '` character is a comment.\nWe\'ll add a short explanation of the aim of the game, and how you move\nthe bird, using a comment line:\n\n# Move the bird using the arrow keys and try to catch the star!\n\nimport pytch\nimport random\n\n\nclass Sky(pytch.Stage):\n    Backdrops = ["clouds.jpg"]\n\n\nclass Bird(pytch.Sprite):\n    Costumes = ["bird.png"]\n    Sounds = ["honk.wav"]\n    speed = 3\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 0)\n        self.set_size(0.3)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.change_x(self.speed)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.change_x(-self.speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.change_y(self.speed)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.change_y(-self.speed)\n\n    @pytch.when_green_flag_clicked\n    def check_catch(self):\n        pytch.wait_seconds(0.1)\n        while True:\n            if self.touching(Star):\n                self.start_sound("honk")\n                self.say_for_seconds("Got you!", 2)\n\n\nclass Star(pytch.Sprite):\n    Costumes = ["star.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-100, 100)\n        self.set_size(0.4)\n        while True:\n            self.show()\n            destination_x = random.randint(-240, 240)\n            destination_y = random.randint(-180, 180)\n            self.glide_to_xy(destination_x, destination_y, 2)\n\n    @pytch.when_green_flag_clicked\n    def check_caught(self):\n        while True:\n            if self.touching(Bird):\n                self.hide()\n\n\n\n', ' Challenges\n\n1. You could add a score to the game so that the bird says things like\n   "Got you 5 times". Create a variable in the Bird sprite, and add\n   one to it every time the star is caught. You can use a variable\n   called "score" in the `say()` command like this: `self.say("Score\n   is " + str(self.score))`. The `str()` command converts a number to\n   a string so that it can be joined with another string using `+`.\n\n2. You could add a second Sprite to chase, which moves faster.\n\n3. You could make the game harder by having the Bird slow down a\n   little after it catches 5 stars (by changing the `speed`\n   variable). After a while you might like to have the Bird speed up\n   again (maybe after some time passes, or after it catches the star\n   again).\n\n\n', ' Credits\n\nWe have used various freely-available resources to help make this\nproject:\n\n{{< asset-credits >}}\n', " Multiple choice quiz\n\nIn this project we're going to make a quiz, where the player has to\nchoose between three possible answers to each question.\n\n---\n\n", ' Make the narrator\n\nOur game will be run by a *narrator*.  We will first make a `Narrator`\nsprite, with a costume of a question mark.  The graphics file for\nthis, `"button-question.png"`, comes with this tutorial.\n\nimport pytch\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n\nIf you run the program now, the question-mark button should appear in\nthe middle of the screen.\n\nLet\'s make the narrator announce the quiz when the program starts.  To\ndo this we\'ll write some code which runs when the green flag is\nclicked:\n\nimport pytch\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\n\n', ' How to store the quiz questions?\n\nBefore we write more code, we need to stop and think about how we\'re\ngoing to store the information needed to make a quiz.  A quiz is made\nup of questions, so we\'ll start by thinking about a single quiz\nquestion.\n\nWhat are the parts of a quiz question?  We need to know:\n\n* the actual question;\n* the three possible answers;\n* which answer is the correct one.\n\nTo record all these things, we\'re going to use a Python feature called\na *list*.  This is very like a Scratch list, but more powerful in ways\nwe\'ll see later on.\n\nThe five items in the list will be\n\n* the question;\n* answer A;\n* answer B;\n* answer C;\n* a letter saying which answer is correct (`"A"`, `"B"`, or `"C"`).\n\nIn Python, the items of a list are written between square brackets\n(`[]`) and have their items separated by commas (`,`).\n\nLet\'s add a question to our program, stored in a variable, to get some\nexperience working with Python lists:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\nYou\'ll see that I\'ve added the code spread across seven lines, to make\nit easier for a human to read.  Python lets you split code across\nlines in some situations, such as when giving the items in a list like\nthis.  Python also allows you to have a comma after the last item in a\nlist, which I\'ve included here.\n\n', ' Working with lists in Python: experimental code\n\nFirst we\'ll explore how to use the different pieces of information in\nthis list.  We\'ll write some code which is not going to be in our\nfinal game.  This code will let us try out a few things and learn how\nlists work in Python.\n\nLet\'s start by printing out the list we\'ve just created, using the\nPython built-in function `print()`:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(question_info)\n\n\nIn standard Python, things you `print()` usually get displayed on the\nscreen.  In Pytch, `print()` output appears in the `Output` tab.  So\nto see what the above code has printed, select the `Output` tab.  Come\nback to this `Tutorial` tab when you\'re ready to continue.\n\nOften we want to get a particular item out of a list.  In Scratch, you\nwould use, for example, this block:\n\n``` scratch\n(item (3) of [colours v])\n```\n\nto get the third item of the `colours` list.  In Python, we use the\nsame `[]`s as are used to write a list.  The other difference between\nScratch and Python is that in Python, the positions are numbered\nstarting at *zero*, so the first item in the list is `[0]`, the second\nitem is `[1]`, and so on.\n\nTo see this working, we\'ll print the first item from our question-info\nlist, by changing the `print()` line:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(question_info[0])\n\n\nChange the code again to print out the second item:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(question_info[12])\n\n\nAnd the fifth:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(question_info[4])\n\n\nJust to see what happens, experiment with asking for the item at a\nposition which doesn\'t make sense.  For example, our list only has\nfive items in it, so it doesn\'t make sense to ask for the item at\nposition 12:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(question_info[12])\n\n\nYou\'ll see an *error* in the `Errors` tab.  Switch back to this\n`Tutorial` tab when you\'ve checked what the error says.\n\nWe\'ve finished exploring this now, so let\'s delete the temporary code:\n\nimport pytch\n\n\nquestion_info = [\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\n\n', " How to store more than one question?\n\nA little bit more thinking now will save us time later.  After the\ntesting we did using `print()`, we're happy that we can get at the\ndifferent pieces of information which make up a single quiz question.\nThe next thing to think about is how we're going to store more than\none question.\n\nWe will put the questions into a list.  In Scratch, the items in a\nlist have to be strings or numbers.  In Python, lists can hold other\nlists, which is perfect for us.\n\n", ' Make a list of lists\n\nWe\'ll make some small changes to the code we\'ve already written, and\nmake a *list of lists* to store the information about the whole quiz.\nFirst remove the `question_info` variable name but keep the opening\nsquare bracket:\n\nimport pytch\n\n\n[\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\nThen add a line opening a new list `all_questions_info` and a line\nclosing that same list:\n\nimport pytch\n\n\nall_questions_info = [\n[\n    "What is the capital of Ireland?",\n    "Dublin",\n    "Cork",\n    "Galway",\n    "A",\n]\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\nIndent the list we already have for storing the first question (this\ncan be done by highlighting the lines and pressing the `TAB` key):\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ]\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\nWe want to be able to add more questions, so add a comma after the\nclosing bracket of our question\'s list:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\nWe\'re now ready to add more questions when we\'re ready, but first\nwe\'ll get some experience working with this idea of a list of lists.\n\n', ' Explore how to get items from the list of lists\n\nAs before, we will use some temporary `print()` function calls to\ncheck we know what\'s going on.\n\nLet\'s print the whole list of lists:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(all_questions_info[0][2])\n\n\nAnd now, instead, we\'ll print that list\'s first item.  This will be\nthe one-question list we had a minute ago:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(all_questions_info[0][2])\n\n\nTo get a particular item from *that* list, we use the `[]` notation\n*again*:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n        print(all_questions_info[0][2])\n\n\nExperiment with changing these numbers and check you understand what\nyou see printed and what errors you get when the numbers don\'t make\nsense.\n\nWhen you\'re happy, get rid of the temporary code:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n\n\n', ' Ask a question\n\nWe\'re now ready to start asking a quiz question!\n\nWe\'ll start by giving a name to the list of information for the\nquestion we\'re going to ask the player.  We only have one question at\nthe moment, so we need the item at position zero in the all-questions\nlist:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n\nNext we will pick out and give names to the individual pieces of\ninformation.  We don\'t *have* to do this (we could, for example, just\nkeep saying `question_info[0]` whenever we want to use the question\nitself), but it makes the program easier to read by a human, which is\nimportant.\n\nThe question itself:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n\n\nAnd the three different answers the player will choose from:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = question_info[1]\n        ans_B = question_info[2]\n        ans_C = question_info[3]\n\n\n(You might notice that we haven\'t used `question_info[4]` yet.  This\nis the item which tells us which answer is correct.  We\'ll use it\nlater.)\n\nNow we want to glue these parts together into one string.  In Scratch,\nyou would do something like\n\n``` scratch\n(join (question) (join (ans_A) (join (ans_B) (ans_C))))\n```\n\nIn Python, you can join strings together using the `+` symbol.  Many\nprogramming languages use `+` for this, because joining two strings\ntogether is a bit like adding them together.\n\nWe\'ll make the text by joining together the question and the three\npossible answers:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = question_info[1]\n        ans_B = question_info[2]\n        ans_C = question_info[3]\n\n        text = question + ans_A + ans_B + ans_C\n\n\nAnd now the narrator can say the final text:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = question_info[1]\n        ans_B = question_info[2]\n        ans_C = question_info[3]\n\n        text = question + ans_A + ans_B + ans_C\n        self.say(text)\n\n\nThis is nearly right, but needs improving.  Let\'s start each answer on\na new line.  In a Python string, the sequence `\\n` gets converted into\na special character which starts a new line, so we want to put some of\nthose in:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = question_info[1]\n        ans_B = question_info[2]\n        ans_C = question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nAnd let\'s label the answers so the player knows which one is which.\nWe\'ll insert `"A: "` before the first answer:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = question_info[2]\n        ans_C = question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nand `"B: "` before the second:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nand `"C: "` before the third:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nNow run your program and check that what the narrator says looks much\nbetter.\n\n\n', ' Add another question\n\nLet\'s now test the way we\'ve decided to store more than one question.\nWe want to add a second item to our `all_questions_info` list.  Just\nbefore the `]` which closes that list, insert an inner list with the\npieces of information needed for another question:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nCheck you understand what the five different items in this list are.\n\nWe can test this by changing which item we pull out of\n`all_questions_info`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_info = all_questions_info[1]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nThe narrator should now ask the new question instead of the original\none.\n\nWhen you\'re happy that this is working, put the code back so it asks\nthe first question:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\n\n', ' Ask both questions\n\nThe next step will be to ask the two questions, one after the other.\n\nWe will need to wait after asking the first question:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n\nAnd then we want the narrator to ask the second question.  To make a\nstart on this, let\'s just copy and paste the code we already have for\nasking the first question:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nTry this now.  What you should find is that the game just asks the\nfirst question twice.  This makes sense, because we just copied the\ncode.\n\nCan you work out what we need to change in this code, so that the\nnarrator asks the second question (which is at position `1` in the\n`all_questions_info` list) instead of the first question (which is at\nposition `0`)?\n\nThis is what we need to change:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_info = all_questions_info[1]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nYour game should now ask both questions, one after the other.\n\n', ' Use a loop to ask both questions\n\nWorking like this is going to get annoying when we have more\nquestions.  We\'re going to use the idea of a *loop* to fix the code\nand make it work with any number of questions.\n\nLook at the difference between the copies of the code.  The only\ndifference is that we ask for the item at a different position in the\n`all_questions_info` list.\n\nTo see how this can be tidied up, we\'ll make a variable to hold the\nposition of the current question.  The word *index* is often used to\nmean what position in a list we\'re talking about, so we\'ll call this\nvariable `question_index`.  To ask the first question, we need\n`question_index` to be zero:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        question_info = all_questions_info[0]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_info = all_questions_info[1]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nAnd we want to use this variable in the code:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_info = all_questions_info[1]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nFor the second question, our index variable needs to be `1`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_index = 1\n\n        question_info = all_questions_info[1]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nAnd we need to use it:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_index = 1\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nTest that your program still works.  It should ask the two questions\none after the other.\n\n\n', ' Loop over the questions\n\nIn Scratch, you could find out how many items there are in a list\ncalled `all_questions_info` by using this block:\n\n``` scratch\n(length of [all_questions_info v])\n```\n\nIn Python we can do something very similar — there\'s a built-in\n`len()` function.  We\'ll use this to compute the value of a variable\ntelling us how many questions there are.  We\'ll do this at the top of\nthe program, just after the list of questions:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_index = 1\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nNow we can put the actual loop in.  This is *similar* to the Scratch\nblocks\n\n``` scratch\nrepeat until <>\n```\n\nor\n\n``` scratch\nrepeat ()\n```\n\nbut not quite the same.\n\nIn Python, we can use a `while` loop, which keeps going as long as a\ntest gives a `True` answer.  We want to keep asking questions as long\nas the index makes sense, i.e., is less than the number of questions.\n\nTo see why we need the index to be less than the number of questions,\nremember that if there are, say, 5 questions, the index values we want\nto go through one at a time are\n\n    0, 1, 2, 3, 4\n\nso the test we want is `question_index < n_questions`.\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n        pytch.wait_seconds(2)\n\n        question_index = 1\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nAnd then we need to move the code to ask the question so that it\'s\n"inside" the `while` loop.  This is the same as how, in Scratch, you\nput blocks inside the `repeat` block.\n\nThe following change looks fiddly, but all that\'s happening is that\nthe code moves across to the right by four spaces.  You can do this in\nthe editor by highlighting the code, and pressing the `TAB` key.\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n        question_index = 1\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nAt the end of each time round the loop, we need to move on to next\nquestion by adding one to the index variable:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n        question_index = 1\n\n        question_info = all_questions_info[question_index]\n\n        question = question_info[0]\n        ans_A = "A: " + question_info[1]\n        ans_B = "B: " + question_info[2]\n        ans_C = "C: " + question_info[3]\n\n        text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n        self.say(text)\n\n\nFinally, we can get rid of the code we copied, since the work is now\nbeing done in our loop:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nTry your program — it should *still* ask both questions, one after the\nother.\n\nIt might seem like we\'ve just done a lot of work for no real benefit,\nbut we\'re about to see why writing this loop is so useful.\n\n(There are other kinds of loops in Python.  We\'ve picked the `while`\nloop for this tutorial.)\n\n\n', ' Add a third question\n\nThis is now easy!  We have written our program so that, to add more\nquestions, the only thing we need to change is the *data*, not the\n*code* itself.  This is a powerful idea in computer programming.\n\nTo add another question, we just add it to our `all_questions_info`\nlist near the top of the program:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\n\n', ' Add the answer buttons\n\nWe\'re making good progress.  The narrator now asks all the questions,\none after another.\n\nWe now need a way for the player to answer the questions.  We\'ll do\nthis by adding three buttons.  The player will click on the button for\nthe answer they think is correct.\n\nWe\'ll start with a button to press if the player thinks "A" is the\nright answer.  This is a new sprite, with a costume that\'s provided\nwith this tutorial:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n\nIf you try this, you\'ll see that the new sprite starts off right on\ntop of the narrator, which is no good.  Make the button move to a\nsensible place when the program starts:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nGoing a bit more quickly now, we can add a button the player can click\nif they think "B" is the right answer.  This is very similar to the\n"A" button, but it has a different costume, and different starting\ncoordinates.\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nAnd one for "C":\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nYou might be thinking that there must be a better way to do this than\ncopying and pasting and making small changes to the code.  You\'re\nright, but those ways would take us too far astray from this tutorial.\n\n\n', ' Wait for player to click an answer button\n\nThere are a few ways different Sprites can work together in Pytch.\nWe\'re going to use a *shared variable* which will say whether the\nplayer has clicked a button yet for this question.  It\'s *shared*\nbecause more than one sprite will use it.\n\nThe narrator will set the variable to `False` when asking a question,\nand each answer button will set it to `True` when it\'s clicked.\n\nBecause the narrator and the three answer sprites all need to work\nwith this variable, we\'ll make it *global* by defining it near the top\nof the program, outside any sprite:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nIn Python, you have to give a starting value to a variable.  We\'re\nusing `False` here, because when the program starts, a button has not\nbeen clicked.\n\nThe narrator needs to work with this variable, and in Python you need\nto say when you\'re using a global variable:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nAs soon as the narrator has asked the question, it needs to record the fact\nthat no button has yet been clicked:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nAnd then the narrator needs to wait until a button has been clicked.\nWe want to keep doing nothing as long as `clicked` is `False`.  We can\nwrite this test in a more natural-sounding way by using the `not`\noperator:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            pytch.wait_seconds(2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nThe `pass` statement here does nothing.  Unlike Scratch, Python needs\nto have *some* statements inside a `while` loop, even if you don\'t\nwant anything to happen, so the `pass` statement is what we use.\n\nWe don\'t need to wait any more:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nWe have solved one half of the problem — we\'ve made the narrator wait\nuntil the `clicked` variable tells us that an answer button has been\nclicked.  But nothing is yet setting that variable to `True`, so the\nnarrator will wait forever!\n\nWhen any answer button is clicked, it needs to set the global\n`clicked` variable to `True`.\n\nMoving a bit more quickly now, we need code which says we\'re using the\nglobal `clicked` variable, and then sets it to `True`.  For the first\nanswer button (`AnswerA`), the code we need is:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nAnd we need the same for `AnswerB`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n\nAnd for `AnswerC`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nNow you should be able to move onto the next question by clicking any\nanswer button.  Try it!\n\n(Again, if you\'re wondering whether there\'s a better way to do all\nthis than copying and pasting code, you\'re right, but we don\'t have\nspace in this tutorial to discuss it.)\n\n\n', ' Check the player\'s answer\n\nWe\'re now very close to a working quiz game.  The narrator asks\nquestions, and the player can click on buttons to answer them.  But we\ndon\'t tell the player whether they got the questions right.\n\nWe need to know *which* answer button the player has clicked.  We\'ll\nuse another global variable for this information, so we\'ll define a\nnew variable near the top of the program:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nThe `None` value is a special Python value which means "nothing" or\n"no value".  We have to assign *something* to a variable when\ncreating it.\n\nStarting with the `AnswerA` sprite, within its\n`when_this_sprite_clicked` code, we need to be able to use this\nvariable.  Add a declaration:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nAnd add code to set the `answer` variable to the answer chosen by the\nplayer if they click `AnswerA`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nWe can do something very similar for `AnswerB`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked\n        clicked = True\n\n\nAnd for `AnswerC`:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nBack in the narrator, once the `clicked` variable has turned `True`,\nwe can use the `[4]` item in our `question_info` list to know what the\ncorrect answer is:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            correct_answer = question_info[4]\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nAnd now we can use an `if`/`else` statement to say something different\ndepending on whether the player\'s answer is correct.  Notice that `==`\n(two equals signs) is how you ask "are these two things equal?".  It\'s\neasy to confuse this with `=` (just one equals sign), which means "set\na variable".\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            correct_answer = question_info[4]\n            if answer == correct_answer:\n                self.say_for_seconds("Correct!", 2)\n            else:\n                self.say_for_seconds("Sorry, that\'s not correct.", 2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nTry your quiz now — the narrator should tell you whether you got each\nquestion right or wrong.\n\n\n', ' Keep track of the player\'s score\n\nA nice feature would be to tell the player how many questions they got\nright.\n\nWe\'ll keep track of the player\'s score as they answer the questions\none at a time.  Only the narrator needs to know the score, so we\'ll\nuse a *local* variable for this.  At the start of the quiz, the player\nhas no points, so we\'ll start `score` off at zero:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        score = 0\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            correct_answer = question_info[4]\n            if answer == correct_answer:\n                self.say_for_seconds("Correct!", 2)\n            else:\n                self.say_for_seconds("Sorry, that\'s not correct.", 2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nIf the player gets a question right, they get a point.  We already\nhave the `if`/`else` code which tells the player whether they got the\nquestion right, so we can add some code here:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        score = 0\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            correct_answer = question_info[4]\n            if answer == correct_answer:\n                self.say_for_seconds("Correct!", 2)\n                score += 1\n            else:\n                self.say_for_seconds("Sorry, that\'s not correct.", 2)\n\n            question_index += 1\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nAfter asking all the questions, we want the narrator to announce the\nscore.  First we\'ll put together the text of what the narrator will\nsay.  We have already seen how to glue strings together to make one\nbig string by using the `+` operator.  But this time it\'s more\ncomplicated, because the pieces we want to join together are:\n\n* the string `"You got"`;\n* the number of questions the player got right — this is the value of\n  the variable `score`;\n* the string `"out of"`;\n* the total number of questions — this is the value of the variable\n  `n_questions`.\n\nBut we can\'t just do\n\n``` python\n"You got" + score + "out of" + n_questions\n```\n\nbecause `score` refers to a *number* not a *string*.  Before we can\nuse `+` to join `"You got"` to the score, we have to convert the value\nof `score` into a string.  Python has a built-in function `str()` for\nthis.\n\nAnother detail is that we need to include the space between `"You\ngot"` and the score, and the spaces around `"out of"`.\n\nPutting this all together, we want to compute\n\n``` python\n"You got " + str(score) + " out of " + str(n_questions)\n```\n\nWe\'ll store the result in the variable `text`.  Be very careful of the\nindentation of the next line of code — it needs to be level with the\n`while` at the top of the loop, so that the new code is *outside* the\n`while` loop.\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        score = 0\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            correct_answer = question_info[4]\n            if answer == correct_answer:\n                self.say_for_seconds("Correct!", 2)\n                score += 1\n            else:\n                self.say_for_seconds("Sorry, that\'s not correct.", 2)\n\n            question_index += 1\n\n        text = "You got " + str(score) + " out of " + str(n_questions)\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nAnd then we can make the narrator make the announcement:\n\nimport pytch\n\n\nall_questions_info = [\n    [\n        "What is the capital of Ireland?",\n        "Dublin",\n        "Cork",\n        "Galway",\n        "A",\n    ],\n    [\n        "How many centimetres are there in one metre?",\n        "10",\n        "100",\n        "1000",\n        "B",\n    ],\n    [\n        "What year was the Anglo-Irish Treaty signed?",\n        "1921",\n        "1922",\n        "1923",\n        "A",\n    ],\n]\n\nn_questions = len(all_questions_info)\n\nclicked = False\nanswer = None\n\n\nclass Narrator(pytch.Sprite):\n    Costumes = ["button-question.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_quiz(self):\n        global clicked\n\n        self.say_for_seconds("Let\'s begin!", 3)\n\n        score = 0\n        question_index = 0\n\n        while question_index < n_questions:\n\n            question_info = all_questions_info[question_index]\n\n            question = question_info[0]\n            ans_A = "A: " + question_info[1]\n            ans_B = "B: " + question_info[2]\n            ans_C = "C: " + question_info[3]\n\n            text = question + "\\n" + ans_A + "\\n" + ans_B + "\\n" + ans_C\n            self.say(text)\n\n            clicked = False\n            while not clicked:\n                pass\n\n            correct_answer = question_info[4]\n            if answer == correct_answer:\n                self.say_for_seconds("Correct!", 2)\n                score += 1\n            else:\n                self.say_for_seconds("Sorry, that\'s not correct.", 2)\n\n            question_index += 1\n\n        text = "You got " + str(score) + " out of " + str(n_questions)\n        self.say(text)\n\n\nclass AnswerA(pytch.Sprite):\n    Costumes = ["button-ans-A.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(-140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "A"\n        clicked = True\n\n\nclass AnswerB(pytch.Sprite):\n    Costumes = ["button-ans-B.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "B"\n        clicked = True\n\n\nclass AnswerC(pytch.Sprite):\n    Costumes = ["button-ans-C.png"]\n\n    @pytch.when_green_flag_clicked\n    def setup(self):\n        self.go_to_xy(140, -120)\n\n    @pytch.when_this_sprite_clicked\n    def notify_answered(self):\n        global clicked, answer\n        answer = "C"\n        clicked = True\n\n\nCongratulations!  You should now have a working quiz game!\n\n\n', " Challenges\n\nHere are some ways you could improve the quiz:\n\n* Add more questions.\n\n* Play a sound when the user gets an answer right, and a different\n  sound if they get an answer wrong.  This tutorial comes with two\n  sounds which might be useful for this, or you can use others.\n\n* Make narrator say the player's score so far, after each question has\n  been answered.\n\n* (Harder:) Make there be *four* possible answers for each question.\n  This tutorial comes with an image of a 'D' button you can use if you\n  like.\n\n\n", ' Image and sound credits\n\n{{< asset-credits >}}\n', " Q*bert: Recreate the cube-hopping action\n\nAs Mark Vanstone explains in [Issue 42 of Wireframe\nmagazine](https://wireframe.raspberrypi.org/issues/42):\n\n> Late in 1982, a funny little orange character with a big nose landed\n> in arcades.  The titular Q*bert’s task was to jump around a network of\n> cubes arranged in a pyramid formation, changing the colours of each as\n> they went.  Once the cubes were all the same colour, it was on to the\n> next level.\n\nIn this tutorial we'll follow Mark's example and create the basics of\nthis classic arcade game.\n\n\n---\n\n", ' Set up the background\n\nOur first job is to set up the playing background.  We\'ll use the\nimage from Wireframe, modified slightly to fit the size of the Pytch\nstage.  The image is bundled with this tutorial, so we just need to\ndefine the sort of *Stage* we will be using in this game:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nIf you run the project now, by clicking the *green flag*, you\'ll see\nthe background.\n\n', ' Define the blocks for making the pyramid\n\nThe game world is a pyramid of blocks.  We\'ll make this in Pytch by\nhaving a `Block` sprite, and create a *clone* of it for every block in\nthe pyramid.  First we\'ll define the `Block` sprite, and say what\ncostumes we\'ll use with it.  The two costumes have different coloured\ntops, one for the starting state, and one which is lit up once Qbert\nhas landed on that cube.\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n\nIf you try the project now (click the green flag), you can see a\nsingle block appear in the middle of the stage.  Our next job will be\nto arrange lots of *clones* of this block into a pyramid.\n\n', ' Make the pyramid\n\nGetting this right is going to require some maths!  The pyramid has\nseven *rows*, and each row has a different number of *blocks* in it.\nEach block will be a clone of the original *Block* sprite.\n\nWe\'ll give each row and block a number.  The bottom row will be *row\nzero*, and within each row, the block at the far left will be *block\nzero* of that row.\n\nThe bottom row (row 0, remember) has seven blocks in it.  The next row\nup (row 1) has six blocks, and so on.  We can see that row number *r*\nhas (7&nbsp;−&nbsp;*r*) blocks in it.\n\nTo work out where to put each block, we need to work out its *x* and\n*y* coordinates.\n\n**\nTODO: Finish this explanation, possibly with the aid of a picture.\n**\n\nPutting this altogether, we can create our clones with this code:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n\n\nIf you green-flag the project now, you\'ll see the pyramid appear block\nby block.\n\nOne tiny detail is that the *original* `Block` sprite is still there,\nand this will complicate things.  We\'ll work round this by hiding the\noriginal once all the clones have been made:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n\n\n', ' Introduce the Q*bert character\n\nNow let\'s bring in our hero!  We\'ll define a *Sprite* for Q\\*bert:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n\nQ\\*bert has four costumes, one for each direction they might face.\n\nIf you run the program now, Q\\*bert will straight away appear in the\nmiddle of the stage, in an odd place as the pyramid gets built\nunderneath.  We\'ll tell Q\\*bert to hide as soon as the game starts:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n\nWe\'ll want Q\\*bert to set themselves up once the pyramid is complete,\nso we\'ll define a method which will listen out for a `"set-up-qbert"`\nmessage.  This method will make Q\\*bert move to the top block, face\ndownhill, and show themselves:\n\n**\nTODO: Explain extra offset of 28.\n**\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.show()\n\n\nThis should happen once the pyramid is ready for Q\\*bert, so we\'ll go\nback to the *Block* sprite and send the `"set-up-qbert"` message once\nwe\'ve created all the clones:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.show()\n\n\nThere\'s another detail we should make sure is right.  Q\\*bert needs to\nappear "in front of" the pyramid of blocks.  More or less by chance,\nthis is what happens at the moment, but it\'s a good idea to make sure,\nin case we rearrange our code later.  So we\'ll bring Q\\*bert to the\n*front* of the drawing:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n\n\n', ' Let the player move Q\\*bert\n\nThe player will control Q\\*bert with the arrow keys.  We\'ll start with\nthe *down* arrow key, which will move Q\\*bert \'southwest\' on the\nscreen.\n\nWe want Q\\*bert to face in the correct direction.  We can check in the\n*Images and sounds* tab to see which image this is — it\'s `"qbert2"`.\nWe want Q\\*bert to move 28 pixels to the left and 42 pixels down, which\nwe\'ll do in 14 steps of "2 left, 3 down" to make the movement smoother.\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.switch_costume("qbert2")\n        for frame in range(14):\n            self.change_x(-2)\n            self.change_y(-3)\n\n\nAnd moving Q\\*bert up is very similar:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.switch_costume("qbert0")\n        for frame in range(14):\n            self.change_x(2)\n            self.change_y(3)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.switch_costume("qbert2")\n        for frame in range(14):\n            self.change_x(-2)\n            self.change_y(-3)\n\n\nIf you try this now, it mostly works.  Q\\*bert can move up and down\n(northeast and southwest on the screen), but there are two problems:\n\n- Q\\*bert can go off the top or the bottom of the pyramid.\n- If you press the up-arrow key twice quickly, Q\\*bert moves at twice\n  the speed.\n\nBecause these problems affect moving up and moving down, it will make\nsense to fix them just in once place in the code.  Our first step is\nto *refactor* the code so the jumping logic only appears once.  That\'s\nwhat we\'ll do next.\n\n', ' Refactor the jumping code\n\nIf you compare the `jump_down()` and `jump_up()` methods, you\'ll\nnotice they are very similar.  The differences are:\n\n- the costume is different\n- the amount we change *x* by is different\n- the amount we change *y* by is different\n\nWe\'ll create a `jump()` method which can work with different values\nfor these three things.  This is very much like a custom block in\nScratch.\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n\n    def jump(self, x_speed, y_speed, costume):\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.switch_costume("qbert0")\n        for frame in range(14):\n            self.change_x(2)\n            self.change_y(3)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.switch_costume("qbert2")\n        for frame in range(14):\n            self.change_x(-2)\n            self.change_y(-3)\n\n\nAnd now we can simplify the original `jump_up()` method, by calling\nour new method with the right values for the *x*-speed, *y*-speed, and\ncostume name:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n\n    def jump(self, x_speed, y_speed, costume):\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.switch_costume("qbert2")\n        for frame in range(14):\n            self.change_x(-2)\n            self.change_y(-3)\n\n\nWe can simplify the `jump_down()` method in the same way:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n\n    def jump(self, x_speed, y_speed, costume):\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n\n', ' Fix the \'double speed jump\' problem\n\nNow there\'s only one place we\'ll need to look at to fix the first of\nour problems, which was that quickly pressing an arrow key twice makes\nQ\\*bert move at double speed.  We only need to look at the `jump()`\nmethod.\n\nThe problem is that the player might press an arrow key while we\'re in\nthe middle of doing the jump.  We\'ll fix this by recording whether\nwe\'re in the middle of a jump, and ignoring arrow key presses if we\nare.\n\nThe first step is to create an *instance variable*, which is very much\nlike a \'for this sprite only\' variable in Scratch.  When we\'re setting\nQ\\*bert up (in response to the `"set-up-qbert"` message), we\'ll set\nthis variable to say we are *not* currently jumping:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n\nThen the first thing we\'ll do when jumping is to record that we are\njumping, and then record that we\'re *not* jumping once we\'ve finished\nthat jump:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n\nNow we can just leave the `jump()` method early, without doing\nanything, if we\'re already mid-jump:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n\n(There\'s still the problem of being able to go off the top or bottom\nof the pyramid.  We\'ll get to that later.)\n\n', ' Finish the movement controls: left and right\n\nWith this done, it\'s now quite easy to let the player move in the\nother two directions.\n\nWe handle the `ArrowLeft` keypress to let the player move Q\\*bert\nleft, which is northwest on the screen:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n\nand the `ArrowRight` keypress to let the player move Q\\*bert right,\nwhich is southeast on the screen:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n', ' Add a little bounce to the jump\n\nTo make the game look better, we\'ll add a bounce to Q\\*bert\'s\nmovement.  We want a bit of extra upwards speed in the *y* direction\nat the start of a jump, and a bit of extra downwards speed at the end\nof a jump.  Each jump is 14 frames long, so we\'ll define a *list* of\nthe extra *y* speeds:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed)\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThose extra bits of speed all add up to zero, so Q\\*bert will still\nend up in the right place at the end of their jump.\n\nAgain, we\'ll now see that it was worth our time to not have the\njumping code copied out four times, because we only need to change the\n`jump()` method.  We include the right bounce amount when changing\n*y*, depending on what frame we\'re on.  In Python, to get a particular\nentry out of a list, we use square brackets `[]`, and we also have to\nknow that Python starts counting at *zero*.  This fits nicely with the\nvalues `0`, `1`, ..., `13` that `range(14)` gives us.\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nWith this, the movement looks a lot better.\n\n', ' Work out where on the pyramid we are\n\nWe\'ll now work on the second problem we noticed, which was that\nQ\\*bert can jump right off the top, bottom, or sides of the pyramid.\nWe\'ll make a method which works out which row we\'re on, and which\nblock within that row.  There\'s more maths here, to \'undo\' the\ncalculation we did to find where to place each Block clone.\n\n**TODO: Do we need to explain that?**\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThis method *returns a value*, like blocks such as *(mouse&nbsp;x)* in\nScratch.  The value here is a pair of numbers.  The first one is the\nrow, and the second the block within that row.\n\nNothing is using this method yet, though, so it\'s hard to tell if it\'s\nworking correctly.  We\'ll make it so pressing `"w"` (for \'where\') will\nprint out where on the pyramid this code thinks we are:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    @pytch.when_key_pressed("w")\n    def print_coordinates(self):\n        print("Qbert is on row %d block %d" % self.pyramid_coordinates())\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nTry this:\n\n- Switch to the *Output* tab.\n- Green-flag the project.\n- Move Q\\*bert around, and press the `"w"` key to check the code is\n  working out Q\\*bert\'s position correctly.\n\nRemember, row zero is the bottom row, and block zero is the far-left\nblock on each row.\n\nYou can come back to the tutorial by clicking on the *Tutorial* tab\nheader.  Once you\'re happy that the calculations are correct, you can\nremove the temporary code:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n', ' Make Q\\*bert fall off the pyramid\n\nNow we know what row and block Q\\*bert is on, it\'s easy to tell\nwhether they are actually on the pyramid or not.  If the row number is\nsmaller than zero then Q\\*bert has fallen off the bottom.  If the row\nnumber is seven or more, then Q\\*bert has fallen off the top.  If\nthe block number is less than zero, then Q\\*bert has fallen off to the\nleft.\n\nThe only slightly tricky one is telling whether Q\\*bert has fallen off\nto the right.  This happens if the block number (which starts at\n*zero* for the left-most block, remember) is equal to or greater than\nthe number of blocks in the row, which, as we worked out above, is\n(7&nbsp;−&nbsp;*r*).  We\'ll broadcast a message if Q\\*bert falls off\nthe pyramid at the end of their jump:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n\n        self.jumping = False\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nIf Q\\*bert falls off, we\'ll make it so they disappear into the\ndistance, by shrinking and then hiding altogether.  Here we\'re using a\nversion of the Python `range()` function where we give the starting\nvalue as a percentage (here, 100), the stopping value as a percentage\n(here, 10), and the \'step\', which here has to be negative to work down\nfrom 100 to 10 in steps of 5.  (In fact, Python stops just *before*\nthe \'stop\' value, but this will look fine for our use.)  In the loop,\nwe\'ll turn the percentage into a value by dividing by 100.\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n\n        self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nIf you try this now, you\'ll see that you can still jump around in a\nstrange way while falling off.  We can fix this by pretending that\nQ\\*bert is still jumping.  We\'ll only set the `jumping` variable to\n`False` if Q\\*bert *didn\'t* fall off, by moving that assignment into\nan `else`:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n', ' Lighting up the blocks Q\\*bert lands on\n\nSince the block is the actor which is going to need to do something\nwhen it\'s landed on, we\'ll do this work in the *Block* class.  We\'re\ngoing to define a method which checks whether the clone\'s position is\nequal to Q\\*bert\'s.  If it is, that block has been landed on and\nshould switch to the lit-up costume.\n\nBut first, we need to make each *Block* clone know its own position.\nWe\'ll set new instance variables in the original *Block* just before\nmaking the clone:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nNow each *Block* clone has this information, we can define a method\nwhich tests whether that *Block* is the one Q\\*bert is on.  We\'ll find\nthe original (in fact, only) Q\\*bert instance, and ask it for its\ncoordinates in pyramid row/block terms, then check whether the Block\'s\nrow-number and block-number match.  If so, light up!\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            self.switch_costume("block-lit")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nAll we need to do now is launch this method by making Q\\*bert\nbroadcast the message:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            self.switch_costume("block-lit")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nWe use `broadcast_and_wait()` to make sure the block checking has\nhappened before allowing Q\\*bert to move again.\n\n', ' Checking Q\\*bert\'s progress\n\nThis is now working quite well, but we need a way to tell whether\nQ\\*bert has cleared the level.  We\'ll track the number of un-lit-up\nblocks Q\\*bert still has left to jump on.  We\'ll store this number in\na *global variable*, which is one that all sprites have access to.  We\ndefine it at the start of the code, outside any `class`:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            self.switch_costume("block-lit")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThis might look strange, since at the start of the game there are\ndefinitely *not* zero un-lit-up blocks.  What we\'ll do is make Q\\*bert\ncount the blocks as soon as the pyramid has been made:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            self.switch_costume("block-lit")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThere are a couple of things to notice here:\n\n- We need to tell Python that it\'s the global variable `blocks_left`\n  we want to set the value of, not make a new local variable.\n- We use the `all_clones()` method on the `Block` *class*, which is a\n  Pytch built-in giving us a list of all the live clones of that\n  class.  We\'re only interested in how many clones there are, so we\n  find the length of that list with the Python built-in `len()`.\n\nNow, when a block works out that it\'s the one Q\\*bert has landed on,\nit will first test whether it\'s already lit up, by checking what\ncostume it\'s wearing.  Only if it\'s *not* already lit up do we switch\nits costume to the lit-up one.\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThis small change hasn\'t made any difference, but we can now do the\nother job required when a block goes from unlit to lit — we can\ndecrease by one the number of blocks left to light up.  Again, we have\nto tell Python that it\'s the global `blocks_left` variable we want to\nwork with:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nTo check this is working, we\'ll make Q\\*bert say the number of blocks\nwhich are left to light up:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.say("%d left" % blocks_left)\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nIf you run this now, it mostly works, except that when you land on the\nvery top block, the count drops by *two* instead of one.  What\'s\nhappening is that the *original* instance of *Block* is updating the\ncount (even though it\'s hidden), as well as the clone which was\ncreated there.  We\'ll fix this by making the original *Block* think\nit\'s in a nonsense position.  This isn\'t a very elegant way of solving\nthis problem, but it will work:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.say("%d left" % blocks_left)\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nOnce you\'re happy this is working, you can remove the diagnostic\nspeech bubble:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n', ' Winning the game!\n\nWhen Q\\*bert has lit up all the blocks, we want to congratulate the\nplayer.  We\'ll do this with a sprite with a message as its costume:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThis Sprite should start off not shown:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nAnd we\'ll define a simple method which puts the sprite in a useful\nplace and shows it when a message is broadcast:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThe only time the level might have been cleared is just after a new\nblock has been lit up, so at that point we\'ll check whether there are\nzero blocks left, and send the `"level-cleared"` message if so:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n\n', ' Making some noise\n\nThe game is now playable, but to make it more interesting we\'ll\ninclude some sounds.  We\'ll start with a victory sound, which will be\na trumpet fanfare.  The \'level cleared\' announcement sprite is a good\none for this sound to belong to:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n    Sounds = ["fanfare.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nAnd we want to play this sound at the same time as showing the\nmessage:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n    Sounds = ["fanfare.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n        self.start_sound("fanfare")\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nThe other sounds will belong to the *Block* sprite, and will play when\na block is landed on by Q\\*bert.  We\'ll make different noises\ndepending on whether the block was already lit up, so we declare two\nsounds for the *Block* sprite:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n    Sounds = ["fanfare.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n        self.start_sound("fanfare")\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n    Sounds = ["pop.mp3", "bell-ping.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nIf a block is lighting up, then we\'ll play the bell:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n    Sounds = ["fanfare.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n        self.start_sound("fanfare")\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n    Sounds = ["pop.mp3", "bell-ping.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.start_sound("bell-ping")\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\nand if a block is already lit up, we\'ll play the pop.  We do this by\nadding an `else` clause to the `if` test for whether the block is\nnewly lit:\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n    Sounds = ["fanfare.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n        self.start_sound("fanfare")\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n    Sounds = ["pop.mp3", "bell-ping.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.start_sound("bell-ping")\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n            else:\n                self.start_sound("pop")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n\n', " Add instructions\n\nTo tell the player how to use our game, we'll add some instructions at\nthe top of our code.  We'll do this using a Python *comment*, which is\na part of your program meant just for human readers — Python ignores\nit.  In Python, a line starting with the `", '` character is a comment.\nWe\'ll add a short explanation of the aim of the game, and how you move\nQ\\*bert, using two comment lines:\n\n# Turn all the blocks yellow by jumping with the arrow keys,\n# but don\'t fall off the pyramid!\n\nimport pytch\n\n\nblocks_left = 0\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["background.png"]\n\n\nclass LevelClearedText(pytch.Sprite):\n    Costumes = ["level-cleared-text.png"]\n    Sounds = ["fanfare.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("level-cleared")\n    def congratulate_player(self):\n        self.go_to_xy(-150, 80)\n        self.show()\n        self.start_sound("fanfare")\n\n\nclass Block(pytch.Sprite):\n    Costumes = ["block-unlit.png", "block-lit.png"]\n    Sounds = ["pop.mp3", "bell-ping.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def create_pyramid(self):\n        for r in range(7):\n            for b in range(7 - r):\n                block_x = -150 + (b * 56) + (r * 28)\n                block_y = -145 + (r * 42)\n                self.go_to_xy(block_x, block_y)\n                self.pyramid_r = r\n                self.pyramid_b = b\n                pytch.create_clone_of(self)\n        self.hide()\n        self.pyramid_r = -1\n        self.pyramid_b = -1\n        pytch.broadcast("set-up-qbert")\n\n    @pytch.when_I_receive("check-block")\n    def check_whether_landed_on(self):\n        qbert_r, qbert_b = Qbert.the_original().pyramid_coordinates()\n        if self.pyramid_r == qbert_r and self.pyramid_b == qbert_b:\n            if self.costume_name == "block-unlit":\n                self.start_sound("bell-ping")\n                self.switch_costume("block-lit")\n                global blocks_left\n                blocks_left -= 1\n                if blocks_left == 0:\n                    pytch.broadcast("level-cleared")\n            else:\n                self.start_sound("pop")\n\n\nclass Qbert(pytch.Sprite):\n    Costumes = ["qbert0.png", "qbert1.png", "qbert2.png", "qbert3.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    # This list must have exactly 14 entries.\n    bounce = [6, 4, 2, 1, 0, 0, 0, 0, 0, 0, -1, -2, -4, -6]\n\n    @pytch.when_I_receive("set-up-qbert")\n    def go_to_starting_position(self):\n        self.go_to_xy(-150 + 3 * 56, -145 + (6 * 42) + 28)\n        self.switch_costume("qbert1")\n        self.go_to_front_layer()\n        self.show()\n        self.jumping = False\n        global blocks_left\n        blocks_left = len(Block.all_clones())\n\n    def pyramid_coordinates(self):\n        y_on_stage = self.y_position\n        pyramid_r = (y_on_stage + 145 - 28) / 42\n        x_on_stage = self.x_position\n        pyramid_b = (x_on_stage + 150 - pyramid_r * 28) / 56\n        return (pyramid_r, pyramid_b)\n\n    def jump(self, x_speed, y_speed, costume):\n        if self.jumping:\n            return\n        self.jumping = True\n        self.switch_costume(costume)\n        for frame in range(14):\n            self.change_x(x_speed)\n            self.change_y(y_speed + self.bounce[frame])\n\n        r, b = self.pyramid_coordinates()\n        if r < 0 or r >= 7 or b < 0 or b >= (7 - r):\n            pytch.broadcast("fall-off")\n        else:\n            pytch.broadcast_and_wait("check-block")\n            self.jumping = False\n\n    @pytch.when_I_receive("fall-off")\n    def disappear(self):\n        for i in range(100, 10, -5):\n            self.set_size(i / 100.0)\n        self.hide()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def jump_up(self):\n        self.jump(2, 3, "qbert0")\n\n    @pytch.when_key_pressed("ArrowDown")\n    def jump_down(self):\n        self.jump(-2, -3, "qbert2")\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def jump_left(self):\n        self.jump(-2, 3, "qbert3")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def jump_right(self):\n        self.jump(2, -3, "qbert1")\n\n\n\n', " Challenges\n\nThis is now a playable game, although quite easy once you get the hang\nof it!  There's lots more you could do with it:\n\n- The player can keep making Q\\*bert jump around the pyramid after\n  clearing the level, which looks odd.  What's the best way to handle\n  this?\n- When Q\\*bert falls off the pyramid, they just get smaller.  It would\n  look better if they looked like they carried on falling, at an\n  increasing speed.\n- Add enemies, like were in the original, such as bouncy balls which\n  you have to avoid.\n- Make there be more than one level.  Different levels could have\n  different colour schemes.\n- Add the safety discs of the original, which transport Q\\*bert back\n  to the top of the pyramid.\n\n\n", ' Credits\n\nMany thanks to the Raspberry Pi Press for making the contents of their\n*Wireframe* magazine available under a Creative Commons licence.  We\nhave used their code for inspiration, and also the images.\n\nMany thanks to Freesound users *greenvwbeetle*, *Robinhood76*, and\n*InspectorJ* for making their sound effects available under friendly\nlicences.\n\n{{< asset-credits >}}\n', " Splat the moles\n\nWe're going to write a game in Python where the player has to splat\nmoles to score points.  But if they miss, they lose all their points!\n(Don't worry, no real moles will be harmed in making this game.)\n\n![screenshot](screenshot-w360.jpg", 'img-center)\n\n---\n\n', ' Create a stage with backdrop\n\nOur first job will be to set up the Stage for our game.  This tutorial\ncomes with a photo of a green field, `green-field.jpg`.  You can check\nwhat it looks like in the "Images and sounds" tab — come back to this\n"Tutorial" tab when you\'ve done that.\n\nIn Pytch, to make our stage, we:\n\n* give it a name (`Field`);\n\n* say what its backdrops should be, using a Python _list_.  Even\n  though there\'s only one backdrop, we still put it in a list, using\n  square bracket `[]` characters.\n\nTo do these two things, we need to add this code:\n\nimport pytch\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nIf you run your program now, with the green flag, you should see the\nphoto appear as the backdrop.\n\n\n', ' Add the mole\'s holes\n\nOur next job is to add the mole.  There are a few different ways we\ncould do this.  For this tutorial, we\'ll have one sprite with a costume\nshowing a row of mole-less holes.  We\'ll add three more costumes, one\nwith the mole popping out of the left hole, one with the mole popping\nout of the centre hole, and one with the mole popping out of the right\nhole.  By making the sprite wear different costumes, we can make it\nlook like the mole is choosing different holes to pop out of.\n\n(If you\'re wondering what other ways we could do this, have a look at\nthe "Challenges" chapter at the end of this tutorial.)\n\nSo we\'ll start off by adding the three empty holes that the mole will\npop out of.\n\nAdd a Sprite for the mole, with a "three empty holes" costume.  You\ncan check the "Images and sounds" tab to see what it looks like.\n\nimport pytch\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n    ]\n\n\n(Python lets you write lists on more than one line like this.  We\'re\ndoing this because in a minute we\'ll need to add some more costumes,\nand the code will be easier for us to read if the `Costumes` list\nisn\'t on one big long line.)\n\nRun your program now — click the green flag.\n\nThis looks alright, but the holes are a bit high up.  Let\'s make it so\nthey\'re a bit lower down the screen.  To do this, we want to write\nsome code that runs as soon as the green flag is clicked.  In Scratch,\nwe would do something like\n\n``` scratch\nwhen green flag clicked:\n  go to x: (0) y: (-70)\n```\n\nwhere the `x: 0` means we want the sprite centred left-to-right, and\nthe `y: -70` means we want the sprite a bit lower than the centre\ntop-to-bottom.\n\nIn Pytch we do something very similar.  We need a line of Python code\nwhich works as the "hat block", and a line of Python code which does\nthe same job as the "go to" block.  One new thing in Pytch is that we\nneed to give our script a _name_.  (If you want to know the details,\nwhat we\'re doing is _defining_ a Python _function_.)\n\nWe\'ll use the name `pop_up_and_down`, because in a minute, this script\nwill also make the mole pop up from a random hole and then back down\nunderground.\n\nThe code we need to add looks like this:\n\nimport pytch\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n\nCheck you understand what each of these three lines of code is doing,\nand then try running your program again.  The row of mole holes should\nbe nearer the bottom of the stage now.  You can adjust the `-70` if\nyou think it would look better a bit higher or lower.\n\n\n', ' Add actual mole costumes\n\nOur `Mole` sprite now needs the rest of its costumes, to show it\npopping up out of each of the holes.  We can add more costumes to the\n`Mole`\'s `Costumes` list like this:\n\nimport pytch\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n\nThis won\'t make any difference to what the game does, because we\nhaven\'t yet told our `Mole` to switch to any of these costumes.  We\'ll\ndo that next.\n\n\n', " Pop out of random holes\n\nTo make the mole pop up out of random holes, we're going to need to\nask Python for some random numbers.  In Scratch, we would use the\nrandom number block\n\n``` scratch\npick random (2) to (4)\n```\n\n", ' Saying we want to use random-number functions\n\nThe Scratch `pick random` block is always available, but in Python we\nhave to say we want to use the Python equivalent.  This is like how in\nScratch we need to turn on extensions like the _Music_ or _Pen_\nblocks.\n\nIn Python, we _import_ the functions that let us choose different\nsorts of random numbers by adding this line just underneath the\n`import pytch` that\'s already there at the top of our program:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n\nThis lets us use Python\'s random-number functions.\n\n', ' Choosing a random hole to pop out of\n\nAnd now we can write some code to get the mole to keep popping up out\nof different holes.  In Scratch, we might do something like\n\n``` scratch\nforever\n  switch costume to (pick random (2) to (4))\n  wait (pick random (0.5) to (1)) seconds\n```\n\nIn Python we do something very similar.  The Python equivalent of\nScratch\'s `forever` is `while True:`.  The Pytch functions we need for\nthe \'body\' of the `while` loop are `pytch.wait_seconds()` and\n`self.switch_costume()`, and then also the functions to get a random\nnumber.\n\nThere are some important differences:\n\n* Scratch works out whether you want whole-number random numbers, or\n  numbers which can have a fractional part.  Python has separate\n  functions for the two jobs:\n\n    * `random.randint(lowest, highest)` chooses a random whole number\n      (\'integer\') from `lowest` to `highest` inclusive.\n\n    * `random.uniform(lowest, highest)` chooses a random number\n      anywhere between `lowest` and `highest`, not necessarily a whole\n      number.\n\n* In Scratch, you give the position of an item in a list by saying the\n  first item is at _position 1_, the second one is at _position 2_,\n  and so on.  _Python counts from zero in this situation_, so in\n  Python, the first item in a list is at _position 0_.\n\nJust like Scratch, you can say which costume you want to switch to\neither by name, or by number.  We want to choose between the costumes\nat positions `1`, `2`, and `3` (remember Python counts from `0`).\n\nPutting this all together, we want to add this code to our\n`pop_up_and_down()` method in the `Mole` sprite:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n\nThere\'s quite a lot going on in just the two lines inside the `while\nTrue:`, so take some time to make sure you\'re happy with what we\'re\ndoing.\n\n', ' Waiting underground\n\nThe final piece to make the mole hide underground in between popping\nout of random holes is to add something like the Scratch blocks\n\n``` scratch\nswitch costume to (all-empty v)\nwait (pick random (0.5) to (1)) seconds\n```\n\ninside the `forever` block.\n\nWe\'ll add two lines of Python code which match these two Scratch\nblocks to the end of the code inside our `while True:` loop:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n\nTry this!  The mole should go round and round spending a random time\nunderground and then popping out of a random hole for a random time.\n\nAdjust the numbers used with `random.uniform()` if you think the mole\nshould spend more or less time popped up or underground.\n\n', ' Experiment with a deliberate bug (optional)\n\nIf you\'re curious to see what happens, make a deliberate mistake by\nchanging the `3` in the line\n\n``` python\nself.switch_costume(random.randint(1, 3))\n```\n\nto `10`, to give\n\n``` python\nself.switch_costume(random.randint(1, 10))\n```\n\nand running your program.  If Python comes up with a random number\nbigger than 3, you\'ll get an error like\n\n``` text\nValueError: could not switch to Costume number 8 in class "Mole": it only has 4 Costumes\n```\n\nAfter you\'ve fixed the deliberate mistake, come back to this\n"Tutorial" tab.\n\n\n', ' Set up scoring\n\nNow let\'s start making the code which lets the player try to splat the\nmole.  The `Mole` sprite will keep score of how many times the player\nhas managed to splat it.\n\nTo keep track of something, our program will use a _variable_.  It\nwill be like a "For this sprite only" variable in Scratch.  In Python,\nto create a variable, you just set it to a value.  There\'s no separate\nstep to create it.\n\nAt the very start of the game, we want to set the score to zero,\nbecause the player hasn\'t splatted any moles yet.  So we\'ll add a\nwhen-green-flag script which sets the score to zero:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n\n\nThe `self.` at the start of `self.score` is what makes it a "For this\nsprite only" variable.\n\nIf you run the game, you won\'t see anything different happen, because\nwe\'re not doing anything with the `Mole` sprite\'s `score` variable.\nIn Scratch, we could display the score by checking the check-box next\nto the variable, or by using this block:\n\n``` scratch\nshow variable [score v]\n```\n\nPytch does have a command like that block, but we have to give a bit\nmore information: We have to say who owns the variable.  Our `score`\nvariable belongs to the `Mole` sprite, which as we\'ve seen, is called\n`self` inside its scripts.\n\nPutting this together, we want to add this line underneath the code we\njust wrote:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n\nUnusually, we give the _name_ of the `score` variable as a _string_\nhere, so make sure you include the `""` characters.\n\nTry this now — you should see a `score 0` display on the stage.\n\n\n', " Hit the left hole\n\nNow let's make it so the player can try to splat the mole!\n\nThe game will be controlled by the keyboard.  The player will:\n\n* press `j` to hit the left hole;\n\n* press `k` to hit the centre hole;\n\n* press `l` to hit the right hole.\n\nWe'll get the code right for `j` (the left hole) first, and then see\nwhat changes are needed for the other two.\n\n", ' Running a script when a key is pressed\n\nIn Scratch we would use the hat block\n\n``` scratch\nwhen [j v] key pressed\n```\n\nand we can do the same thing in Pytch, remembering that we have to\ngive a name to the script.  We\'ll add the start of a new script to our\n`Mole` sprite:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n\n\nIf you try to run this now, you\'ll get a _Syntax Error_ saying _There\nis a body or indentation missing_.  Python needs a script (_function_)\nto have a _body_, and we haven\'t written it yet.\n\n', ' Knowing if the mole is popped out of the left hole\n\nThere are a couple of things we need to know next:\n\n* How do we know which costume the `Mole` sprite is wearing?  Remember\n  that there is one costume for each hole the mole might pop out of,\n  as well as a costume for when the mole is hiding underground.\n\n* How do we do different things depending on whether the mole is\n  popped out of the left hole?\n\nFor the first question, we can get Pytch to tell us what costume the\n`Mole` sprite is wearing.  In Scratch, we could use this reporter\nblock:\n\n``` scratch\n(costume [number v])\n```\n\nWe can do something similar in Pytch, by using `self.costume_number`\ninside a `Mole` script.\n\nIf the mole is popped out of the left hole, this will be `1`.  If the\nmole is popped out of another hole, it will be `2` or `3` (depending\nwhich hole), and if the mole is hiding underground, it will be `0`\n(the "all-empty" costume is the first one, which is at _position 0_).\n\nSo we want to ask\n\n> Is the `Mole` sprite\'s costume number equal to 1?\n\nand then only give the player a point if the answer is \'yes\'.  Scratch\nhas an `if` block for this, which we would use something like\n\n``` scratch\nif <(costume [number v]) = (1)> then\n  change [score v] by (1)\n```\n\nOne thing to watch out for is that in Python, we ask whether two\nthings are equal by writing `==`, which has _two_ equals signs.\nRemembering this, the code looks like:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.score += 1\n\n\nTry it!\n\n\n', ' What if the player misses?\n\nBut this is now too easy.  The player can just keep pressing `j` and\nwhenever the mole pops out of the left hole, the player scores a\npoint.  There needs to be a way to discourage the player from doing\nthis.\n\nLet\'s be harsh — if the player misses, they lose all their points.\nThis should happen if the player presses `j` but the `Mole` sprite is\n_not_ wearing costume number `1`.  We need something like Scratch\'s\n\n``` scratch\nif <> then\nelse\nend\n```\n\nblock.  In Python, it\'s very similar — we add an `else` to the `if` we\nalready have:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.score += 1\n        else:\n            self.score = 0\n\n\nYou might think this is a bit _too_ harsh!  Have a look at the\n_Challenges_ at the end of this tutorial for some other ideas.\n\n', ' Make a splatted mole go back underground\n\nThere\'s still a small way the player can unfairly get more points.  If\nthey keep hitting `j` while the mole is popped up out of the left\nhole, they can rack up points.\n\nLet\'s make the mole go back underground when the player splats it.  We\ncan do this just by making it switch back to the `"all-empty"`\ncostume:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.score = 0\n\n\nTry it now!\n\n\n', ' Add sound effects\n\nLet\'s add some sounds to the game.  This tutorial comes with some\nexamples, or you can find and use your own.  Just as we need to list\nthe image files we want a sprite to be able to use for its costumes,\nwe need to list the sound files we want a sprite to be able to use.\n\nAdd a variable `Sounds` near the top of the `Mole` sprite, just after\nthe `Costumes`:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n    Sounds = ["splat.mp3", "thud.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.score = 0\n\n\nNow we just need to start the right sound playing depending on whether\nthe player has hit the mole or missed it.  To play the "splat"\nsound if they hit it, add this code:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n    Sounds = ["splat.mp3", "thud.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.score = 0\n\n\nAnd to play a "thud" sound if they miss, add:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n    Sounds = ["splat.mp3", "thud.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.start_sound("thud")\n            self.score = 0\n\n\n\n', ' Hit the other holes\n\nWe\'ve done all the work now.  We can finish the game by copying  the\ncode for the left hole, and pasting it twice — once for the centre\nhole and once for the right — with small changes.\n\nWe need to be very careful that we make the changes we need when\ncopy/pasting.  To change the left-hole code into code for the\ncentre-hole, we need to:\n\n* React to the `k` key (instead of the `j` key).\n\n* Give the function a different name: `hit_centre` (instead of\n  `hit_left`).\n\n* In the `if` statement, ask whether `self.costume_number` is equal to\n  `2` (instead of `1`).\n\nMaking these changes, we get this new code for the centre hole:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n    Sounds = ["splat.mp3", "thud.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.start_sound("thud")\n            self.score = 0\n\n    @pytch.when_key_pressed("k")\n    def hit_centre(self):\n        if self.costume_number == 2:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.start_sound("thud")\n            self.score = 0\n\n\nAnd along the same lines, we get this for the right hole:\n\nimport pytch\nimport random\n\n\nclass Field(pytch.Stage):\n    Backdrops = ["green-field.jpg"]\n\n\nclass Mole(pytch.Sprite):\n    Costumes = [\n        "all-empty.png",\n        "left-mole.png",\n        "centre-mole.png",\n        "right-mole.png",\n    ]\n    Sounds = ["splat.mp3", "thud.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def pop_up_and_down(self):\n        self.go_to_xy(0, -70)\n\n        while True:\n            self.switch_costume(random.randint(1, 3))\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n            self.switch_costume("all-empty")\n            pytch.wait_seconds(random.uniform(0.5, 1.0))\n\n    @pytch.when_green_flag_clicked\n    def set_up_scoring(self):\n        self.score = 0\n        pytch.show_variable(self, "score")\n\n    @pytch.when_key_pressed("j")\n    def hit_left(self):\n        if self.costume_number == 1:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.start_sound("thud")\n            self.score = 0\n\n    @pytch.when_key_pressed("k")\n    def hit_centre(self):\n        if self.costume_number == 2:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.start_sound("thud")\n            self.score = 0\n\n    @pytch.when_key_pressed("l")\n    def hit_right(self):\n        if self.costume_number == 3:\n            self.start_sound("splat")\n            self.score += 1\n            self.switch_costume("all-empty")\n        else:\n            self.start_sound("thud")\n            self.score = 0\n\n\n(If you\'re wondering whether there\'s a better way then copying and\npasting, there is, but it\'s outside the scope of this tutorial.)\n\n', ' Game complete!\n\nTry the finished game!\n\n\n', ' Challenges and questions\n\nMaybe you can think of ways to make this game better.  Here are some\nideas:\n\n* Find and use a different backdrop.  Add more than one backdrop, and\n  change between them randomly, or as the player gets more points.\n\n* Find and use different sound effects.  Maybe choose randomly between\n  different effects to make the game more interesting.  The site\n  `freesound.org` has lots of good sound effects.\n\n* Perhaps it\'s a bit harsh for the player to lose all their points\n  when they miss.  Maybe they should lose some fixed number of points\n  instead.  Change the code (in three places!) so that the player\n  loses five points if they miss.  You can use the Python operator\n  `-=` to subtract points.  What happens if they only have three\n  points when they miss?\n\n* Instead of losing points, the player could start with three lives,\n  and they lose a life every time they miss.  Hint: You can show a\n  variable at the _right_ of the screen with the code\n  `pytch.show_variable(self, "lives", right=236)`.\n\n* Adjust the difficulty of the game by making the mole stay out of its\n  hole for a longer or shorter time.  You could even make the game get\n  more difficult as the player gets more points.\n\n', ' Other ways of doing things\n\nThere is often more than one way to write a program.  Here are some\nways you could investigate writing the program differently to how this\ntutorial did it:\n\n* The `Mole` sprite has two green-flag scripts.  Can you combine them\n  into one script?  Do you think the program is easier to understand\n  with two green-flag scripts or one?\n\n* **Advanced:** Instead of one `Mole` sprite with four costumes, we\n  could have made three sprites: `LeftMole`, `CentreMole`, and\n  `RightMole`, each with two costumes: an "empty hole" one and a "mole\n  popping out of hole" one.  This tutorial comes with suitable\n  graphics files.  See if you can re-write the game this way.  Some\n  questions you might want to think about:\n\n    * Should it be possible for more than one mole to be out of its\n      hole at the same time?\n\n    * How will you keep track of the score?  One way would be to use a\n      _global variable_.\n\n    * With one sprite per mole/hole, you could let the player click or\n      tap to hit a hole, instead of using the keyboard.  Do you think\n      that would be better?  Can you change the code so it reacts to\n      the sprite being clicked?\n\n\n', ' Credits\n\nWe have used various freely-available resources to create this\ntutorial:\n\n{{< asset-credits >}}\n', " Shoot the fruit\n\nWe're going to write a game in Python where the player has to click on\nfruit to score points.  We'll write the game in a very similar way to\nhow we'd create it in Scratch.\n\n![screenshot](screenshot.png", 'img-center)\n\n---\n\n', ' Create a stage with backdrop\n\nThe first thing we\'ll do is to create a *Stage* for the game.  To keep\nthings simple, we\'ll use a solid dark green background.\n\nIn Scratch, there is automatically a Stage for your project.  In\nPytch, we have to create it.  We\'re going to call it `GameBackground`,\nand we need to say that it\'s the `Stage` for our game.\n\nIn this tutorial, we\'ll show the code we need in boxes like this — the\nblue `?` will show help on what to do:\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n\n\nHere, we need to add two blank lines under the `import pytch` line\nwhich is already there, and then the line starting `class\nGameBackground`.\n\nPython ignores the blank lines, but they keep our code tidy and easy\nto read.\n\nThis code does not yet make sense, so if you click the green flag you\nwill get an error!  Come back to this *Tutorial* tab if that happens.\n\nIn Pytch, the stage has *backdrops*, like in Scratch.  To say what\nbackdrops we want, we set a variable called `Backdrops` for the\nstage.  If you look in the *Images and sounds* tab, you\'ll see an\nimage called `"solid-green.png"`.  We\'ll use this by adding a line of\ncode to our program:\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nThe square brackets `[` and `]` mean that this is a *list* of\nbackdrops.  Our stage here only has one backdrop, but we still\nneed to write `Backdrops` as a list.\n\nTry your program now — click the green flag.  You should see the dark\ngreen backdrop appear.\n\n\n', ' Create the fruit\n\nNow we\'ll add a *Sprite* for the fruit which the player has to shoot.\nIn Scratch you would click on the "add Sprite" button.  In Python we\nadd some code to our program.  We\'ll call our new Sprite `Fruit`, and\nwe need to say that it\'s a Sprite.  This is the code we need:\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n\n\nJust like in Scratch, Sprites in Pytch have *costumes*.  We set a\nvariable to the list of costumes we want our Sprite to have.  For now,\nwe only have one costume, `"apple.png"`.\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n\nTry your program — if you click on the green flag, you should see an\napple in the middle of the stage.\n\n\n', ' Let the player click the fruit\n\nWe need to make something happen when the player clicks on the apple —\nwe\'ll make the fruit disappear.  In Scratch you would do something\nlike\n\n```scratch\nwhen this sprite clicked\nhide\n```\n\nThis has two parts:\n\n* We say *when* we want something to happen using a "hat block" — when\n  this sprite clicked.\n\n* We say *what* we want to happen by connecting other blocks\n  underneath the hat block — the *hide* block.\n\nThings work nearly the same in Pytch.  To say *when* we want something\nto happen, we use a special marker in the code:\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n\n\nIn Python, we need to give a name to the section of code we want to\nrun.  This piece of code will run when the fruit is hit, so we\'ll call\nit `hit_fruit`.\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n\n\n(The `def` is short for *define* — we\'re about to define the section\nof code called `hit_fruit`.  The `self` is like a variable which will\nrefer to the Sprite being clicked.)\n\nFinally, we say what we want to happen when the Sprite is clicked — we\nwant it to *hide*:\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n\nThe `self` means that we want *this* Sprite to hide.\n\nWhen you have added the code to your program, test it!  Click the\ngreen flag and check that:\n\n* the apple disappears when you click on it;\n* the apple does *not* disappear when you click somewhere random on\n  the green background.\n\n\n', ' Make the apple reappear after being hit\n\nThe game is not very exciting yet.  Once the player clicks on the\napple, it disappears, and that\'s it.  We need to make the apple\nreappear so the player can keep playing.\n\nAfter the fruit has hidden itself, we want it to wait for a short\ntime, and then show itself again.  In Scratch, we would add these\nblocks to the bottom of the \'when this sprite clicked\' script:\n\n```scratch\nwait [1] seconds\nshow\n```\n\nIn Python, we add two lines to our code:\n\nimport pytch\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n        self.show()\n\n\nTry the program now!  The apple should disappear when you click it,\nthen reappear one second later.\n\n\n', ' Make the apple reappear somewhere else\n\nThe game is better now, but still not very exciting.  The player knows\nwhere the apple is going to appear.  We want the apple to reappear at\na random place on on the stage.\n\n', ' Saying where to go on the stage\n\nLike in Scratch, positions on the Pytch stage are described by two\nnumbers, `x` and `y`:\n\n* The `x` number says how far right of the centre we are (and so `x`\n  is negative if we are *left* of the centre).\n* The left-right centre of the stage is `x = 0`, far left is `x =\n  -240`, and far right is `x = 240`.\n* The `y` number says how far above the centre we are (and so `y` is\n  negative if we are *below* the centre).\n* The up-down centre of the stage is `y = 0`, the very bottom is `y =\n  -180`, and the very top is `y = 180`.\n\n', ' Picking a random number\n\nWe\'ll need to randomly pick `x` and `y` numbers for where the apple\nreappears.\n\nTo do this, we will use some code that the Python team have written\nwhich picks random numbers.  We first need to say that we want to use\nthis code.  In Scratch, we can "add an extension" to be able to use\nmore blocks.  In Python, we use an *import* statement:\n\nimport pytch\nimport random\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n        self.show()\n\n\n(You might notice that our program starts off with `import pytch` —\nthis is what tells Python that we want to be able to use things like\n`pytch.wait_seconds`.)\n\nWe will use the `randint` \'function\' of this `random` code, to pick\nrandom numbers for us, and choose where the apple will reappear.  We\nwill need to tell `randint` the smallest and biggest possible numbers\nwe want.\n\nIn Scratch you would put this information into the \'holes\' of\nthe block.  For example, to roll a dice you might say:\n\n```scratch\npick random [1] to [6]\n```\n\nIn Python, we put the pieces of information between brackets `(` and\n`)`.  This Scratch block would look like this in Python:\n\n```\nrandom.randint(1, 6)\n```\n\n', ' Picking a random place to appear\n\nWe want to pick a random `x` number and a random `y` number to say\nwhere the apple should reappear.  We will store these values in\n*variables*.  These work very much like Scratch variables.  In Python,\nyou don\'t need to explicitly \'make a variable\' — you just set a\nvariable to something and it is created for you.\n\nWe will make a variable called `appear_x` to hold the `x` number for\nwhere we want the apple to reappear:\n\nimport pytch\nimport random\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n\n        self.show()\n\n\nThe `-200` and `200` don\'t go all the way to the edges of the stage,\nbecause we want the apple to always definitely be completely on the\nstage — it\'s the centre of the apple which we are picking a location\nfor.\n\nWe will set another variable, `appear_y`, to hold the `y` number:\n\nimport pytch\nimport random\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n\n        self.show()\n\n\nWe use `-140` and `140` rather than `-180` and `180` to make sure the\napple doesn\'t go off the top or off the bottom of the stage.\n\n', ' Appear at the random location\n\nNow we know where we want the apple to randomly reappear, we can make\nit go there just before showing itself.\n\nIn Scratch, we can use variables to \'fill in holes\' in blocks, like:\n\n```scratch\ngo to x: (appear_x) y: (appear_y)\n```\n\nIn Python, we put the variables in `()`s:\n\nimport pytch\nimport random\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\n', ' Try it!\n\nRun your program with the green flag.  The apple should reappear in a\nrandom place every time you click it.\n\n\n', ' Show the player\'s score\n\nIt would be good if the player knew how well they were doing.  We want\nto keep a *score*, and give the player a point every time they shoot\nthe fruit.\n\nWe will set this variable at the top of our program.  When the game\nstarts, the player has no points, so we set our new `score` variable\nto zero.  In Scratch we would say\n\n```scratch\nset [score v] to [0]\n```\n\nand in Python, we use this code, which creates the variable and sets\nit to zero:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\n', ' Showing the score\n\nIn Scratch you can just tick a box to show a variable on the stage.\nIn Pytch we write code to do this.  We want to do this as soon as the\ngreen flag is clicked, so we\'ll need code to act like Scratch\'s "when\ngreen flag clicked" hat block.  We\'ll put this in the `GameBackground`\n(our stage), because it\'s part of the overall game.\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nShowing a variable in Pytch uses a couple of more advanced ideas, so\nfor this tutorial, we won\'t go into the details.  The code we need is:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nSo far our program has no way for the player to get points, so the\nscore will be stuck at zero.  We will fix this next.\n\n\n', ' Give the player points\n\nTo increase the player\'s score, in Scratch we would do\n\n```scratch\nchange [score v] by [1]\n```\n\nPython has `+=` (\'change by adding\'), which works very much the same.\nThe code we want is\n\n```\nscore += 1\n```\n\nand it needs to go in our code which runs when the `Fruit` is clicked.\nThere is a detail we need to deal with first, which is to tell Python\nthat we want to change the *global* variable `score`.  A \'global\'\nvariable is very like a "for all sprites" variable in Scratch.  Add\nthese lines to the `hit_fruit` code:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nTry it!  The score should now count how many times the player has\nhit the fruit.\n\n\n', ' Knock off points if player misses\n\nTo make the game more challenging, we\'ll make it so if the player\nmisses the fruit, they lose points.\n\nWe can tell if the player misses by making our stage run some code\nwhen *it* is clicked.  We\'ll start by adding code to act like\nScratch\'s "when stage clicked" hat block:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nWe need a name for the chunk of code we\'re about to write.  The code\nwill run when the player misses the fruit, so `missed_fruit` is a good\nname:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n    def missed_fruit(self):\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nAnd now we can knock off points if a click gets through to the stage.\nJust as when we gave the player points, we need to tell Python that we\nwant to change the global `score` variable.  And this time, instead of\n*adding* to `score` by using `+=`, we want to *subtract* from `score`,\nso we use `-=` (\'change by subtracting\').  This code knocks off five\npoints when the player misses:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n    def missed_fruit(self):\n        global score\n        score -= 5\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\n', ' Stopping the score going negative\n\nThere is a problem with this: What happens if the player misses when\ntheir score is less than five?  Try it — run your game and\ndeliberately miss with your first click.  You\'ll see that the game\nsays your score is `-5`.  This is not very sensible.\n\nAfter knocking off five points with `score -= 5`, we want to test\nwhether the score has become negative.  If so, we want to set `score`\nto zero.  Python has an `if` statement which works the same as\nScratch\'s *if* block.  This is the code we need:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n    def missed_fruit(self):\n        global score\n        score -= 5\n        if score < 0:\n            score = 0\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nThe `score < 0` part is the test — it asks whether the `score`\nvariable is less than zero.  If it is, the *indented* (pushed to the\nright) code runs.  Here, there is only one indented line, which sets\n`score` to zero.\n\n\n', ' Game complete!\n\nThis is now a playable game written in Python — congratulations!\n\nPlay a few games and see how quickly you can score points.\n\n\n', ' Extra: Add another fruit\n\nTo make the game look more interesting, we can add another fruit.\n\n', ' Add a costume\n\nAt the moment, the `Fruit` sprite only has one costume.  We want to\nadd another one.  There is an image `"orange.png"` included with this\ntutorial, so we just need to tell Pytch to use it, by adding it to the\nFruit\'s `Costumes` list.  In Python, the things in a list are written\nwith commas between them.  So we need to change the line which sets\nthe Fruit\'s costumes:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n    def missed_fruit(self):\n        global score\n        score -= 5\n        if score < 0:\n            score = 0\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png", "orange.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        self.show()\n\n\nThe box explains this change as deleting the `Costumes` line and\nadding a replacement, but you can just type in the new part\n\n```\n, "orange.png"\n```\n\nif that\'s easier for you.\n\n', ' Choose a random costume\n\nWe have already used the Python function `random.randint` to pick\nrandom numbers for where to appear on the screen.  There is another\nfunction — `random.choice` — which chooses a random thing from a\nlist.  We\'ll use this to set a variable to the name of the costume we\nwant the Fruit to wear when it reappears.\n\nFind the right place in `hit_fruit` to add this code:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n    def missed_fruit(self):\n        global score\n        score -= 5\n        if score < 0:\n            score = 0\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png", "orange.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        new_costume = random.choice(["apple", "orange"])\n\n        self.show()\n\n\n', ' Switch to the chosen costume\n\nAnd just like Scratch has a *switch costume to* block, Pytch has a way\nto get a Sprite to wear a different costume.  We\'ll use this to switch\nto the costume we just randomly picked:\n\nimport pytch\nimport random\n\n\nscore = 0\n\n\nclass GameBackground(pytch.Stage):\n    Backdrops = ["solid-green.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_score(self):\n        pytch.show_variable(None, "score")\n\n    @pytch.when_stage_clicked\n    def missed_fruit(self):\n        global score\n        score -= 5\n        if score < 0:\n            score = 0\n\n\nclass Fruit(pytch.Sprite):\n    Costumes = ["apple.png", "orange.png"]\n\n    @pytch.when_this_sprite_clicked\n    def hit_fruit(self):\n        self.hide()\n\n        global score\n        score += 1\n\n        pytch.wait_seconds(1)\n\n        appear_x = random.randint(-200, 200)\n        appear_y = random.randint(-140, 140)\n        self.go_to_xy(appear_x, appear_y)\n\n        new_costume = random.choice(["apple", "orange"])\n        self.switch_costume(new_costume)\n\n        self.show()\n\n\n\n', " Challenges\n\nCan you change your program to solve these challenges?\n\n* Give the player 10 points for every fruit they hit instead of 1.\n\n* Give the player 5 points for an apple and 10 points for an orange.\n  (*Hint:* You can use the code `self.costume_name` to find out what\n  costume the sprite is currently wearing.)\n\n* Make the fruit smaller, so it's harder to hit.  (*Hint:* You can use\n  the code `self.set_size(0.5)` to shrink a Sprite to half its normal\n  size.)\n\n* Harder challenge: Make the fruit smaller if the player has more\n  points.  This makes the game get more difficult as the player gets\n  better at it.\n\n\n", ' Credits\n\nWe have used various freely-available resources to create this\nproject:\n\n{{< asset-credits >}}\n', ' A vending machine for tickets\n\nOur task is to make a simulation of a vending machine selling\ntickets for a theme park.  The customer chooses between three sorts of\ntickets, which have different prices.  The customer then pays using\ncoins or notes.  Finally, the machine displays how much change the\ncustomer should receive.\n\nThe available tickets are:\n\n* An adult ticket (€10)\n\n* A child ticket (€6)\n\n* A family ticket (€20)\n\nOnce a ticket has been chosen, the customer can insert €1 or €2 coins,\nor €5 notes.\n\n(This project was suggested as part of the course [*Programming\nPedagogy in Secondary Schools: Inspiring Computing\nTeaching*](https://www.futurelearn.com/courses/secondary-programming-pedagogy)\npublished by the Raspberry Pi Foundation on the FutureLearn platform.\nThe project summary text above and the concept of the project as a\nwhole are adapted from material in that course, which was created by\nthe [Raspberry Pi Foundation](https://www.raspberrypi.org/) and is\nlicensed under the [Open Government Licence\nv3.0](http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/).)\n\n---\n\n', ' Planning: Main parts of the program\n\nBefore we start writing any code, our first job is to think about how\nto break down the program into smaller chunks.  We will then write\ncode for the parts one at a time, breaking each part down further as\nwe go along.\n\nFrom the task description, we can see that there are three main parts,\nwhich happen in this order:\n\n1. Let the customer choose a ticket.\n\n1. Let the customer pay for that ticket.\n\n1. Show how much change the customer needs.\n\nWe will now think a bit more about what has to happen in each of these\nsteps, and then start work.\n\n', " Choosing the ticket\n\nWe will show the three tickets, and let the customer click on the one\nthey want.  We'll need to remember which ticket they chose.\n\n", " Paying for the ticket\n\nOnce we know what ticket the customer wants, we will show the two\ncoins and one note, and let the customer click on them until they have\nadded enough money.  We'll need to keep track of how much money has\nbeen received by the machine.\n\n", " Showing the change\n\nOnce the customer has put enough (or maybe too much) money in, we'll\nneed to work out how much change the customer needs (if any), and show\nthis amount.\n\n\n", ' Add a Sprite for the tickets\n\nWe want the customer to see the three ticket types, and be able to\nclick on one of them to make their choice.  The screen will show the\nthree tickets in a column, like this:\n\n![Ticket menu](ticket-type-menu.png', 'img-float-left)\n\nJust as we would do in Scratch, we will create a Sprite to be the\ntickets.  We could make three Sprites, one for each sort of ticket,\nbut that would lead to a lot of copied code.  Instead we will make\njust one Sprite, and use *clones* to show the different types of\nticket.\n\nOur first job is to create a `Ticket` Sprite, and say that its\ncostumes are the three types of ticket.  Images for these tickets are\nsupplied as part of this tutorial — you can switch over to the "Images\nand sounds" tab to see, and then switch back to this "Tutorial" tab.\n\nIn Pytch, you create a Sprite by *defining a `class`* for that Sprite,\nwith code like:\n\n    class Ticket(pytch.Sprite):\n\nthen the code for that Sprite goes next.  You\'ll see this shortly.\n\nIn Pytch, you say what costumes a Sprite has by setting a `Costumes`\nvariable inside that Sprite.  You set `Costumes` to a Python list of\nthe images you want to use for costumes.  (You can do more advanced\nthings with costumes, but we won\'t need that for this project.)\n\nPutting that all together, the starting code for our `Ticket` sprite\nlooks like this:\n\nimport pytch\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n\nAdd those lines to your code, and try to predict what will happen when\nyou run your program.  Then click the green flag and see if you were\nright.\n\n\n', ' Show all ticket types\n\nWe will write code to display all three ticket types when the green\nflag is clicked.\n\n', ' Child ticket\n\nWe start by moving the `Ticket` sprite to a good place for the child\nticket.  This is centred left-to-right, and quite near the top.  This\nshould happen when the program starts.  In Scratch, we would put\ntogether a script like this:\n\n```scratch\nwhen green flag clicked\nswitch costume to (child v)\ngo to x: [0] y: [120]\n```\n\nAnd in Pytch we do something very similar — add this code to your\nprogram:\n\nimport pytch\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.go_to_xy(0, 120)\n\n\nThe main difference is that in Pytch we have to give the method a\nname; `show_tickets()` is short and describes what the method does.\n\nYou can adjust the `120` in that piece of code if you think the ticket\nshould be a bit higher or lower.  Experiment until you\'re happy with\nit.\n\n', ' Adult ticket\n\nTo also show the adult ticket, we need to make a *clone* of the\n`Ticket` sprite, and change the original `Ticket`\'s costume to the\nadult ticket, and move it to where we want the adult ticket to be.\n\nThere will be two snippets of code, which should look familiar\ncompared to the blocks you would use in Scratch.\n\nOne snippet will make the `Ticket` change to the adult-ticket costume\nand move to the middle of the stage:\n\n    self.switch_costume("adult")\n    self.go_to_xy(0, 0)\n\nAnd the other snippet will make a clone of the `Ticket`, exactly as it\nis when the snippet runs:\n\n    pytch.create_clone_of(self)\n\nWe need to decide the right order for these two snippets.  Should we\n\n* Make a clone and then move the original to the new position with the\n  new costume?\n\n* Move the original to the new position with the new costume and then\n  make a clone?\n\nDecide which order you think is correct, then look at the new code\nbelow to see whether you were right:\n\nimport pytch\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.go_to_xy(0, 0)\n\n\nThe right order is to make a clone of the `Ticket` while it\'s still\nshowing the `child`-ticket costume, and then make the original\n`Ticket` change to the `adult`-ticket costume and move to its new\nposition.\n\n(Try to predict what would happen if you had the `create_clone_of()`\ncall after the `switch_costume()` and `go_to_xy()` calls.  Then\ntemporarily change the code, run it, and see if you were right.)\n\n', ' Family ticket\n\nFinally, we can do the same thing to show the `family` ticket.  We\ncreate a clone of the `Ticket` which is showing the adult ticket, and\nthen switch the original `Ticket` to the `family`-ticket costume and\nmove it to the correct place.\n\nimport pytch\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.go_to_xy(0, -120)\n\n\n\n', ' Make each Ticket clone know its cost\n\nAs well as being in different places on the screen, there is another\nway we need the tickets to be different — they should all cost\ndifferent amounts.  We will store the cost of each ticket in a\nvariable belonging to that clone.  These variables work very like\nScratch\'s "for this Sprite only" variables.  In Python, though, you\njust assign to a variable.  There is no separate step to create the\nvariable.\n\nWe will put the lines of code which set this variable just below the\nlines which switch the costume, to make sure we get the right cost\nwith the right costume.\n\nimport pytch\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n\nWhen each clone is created, part of the cloning process is to copy the\n`cost` variable, with its value at the moment the clone was created.\nThis way we end up with three `Ticket`s, each having their own `cost`\nvariable.\n\n', ' Remember cost of chosen ticket\n\nOnce the customer clicks on one of the tickets, our program needs to\nremember the cost of that ticket.  We will use a global variable for\nthis.  Global variables in Pytch are very like Scratch\'s "for all\nSprites" variables.  In Python, we can assign to a variable at the\n"top level" of our program, which means outside any function, class,\nor method.  Often we put this assignment near the top of the program.\n\nWhen our program starts, the customer hasn\'t chosen a ticket yet, so\nwe will set the variable\'s initial value to `None`, which is the\nPython way of saying \'no value\'.  The code looks like this:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n\nWe now want each ticket clone to react to being clicked, by storing\nits own cost into that global variable.  We can use the value of each\nticket\'s own `cost` variable.  We will write a method and ask Pytch to\nrun it when the sprite is clicked.  In Scratch, this would look like:\n\n```scratch\nwhen this sprite clicked\nset [ticket-cost v] to (cost)\n```\n\nAnd in Pytch, we have to give this method a name, and then the idea is\nthe same:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n\n\nOne detail in this code is that we need to tell Python that we want to\nset the value of the *global* `ticket_cost` variable.  We tell Python\nthis by saying `global ticket_cost`.  Without this, the code would set\na new variable `ticket_cost` which would exist just inside our method.\n\n', ' Test the program so far\n\nWhen we were writing code to show the ticket types, it was obvious\nwhether our program was working — we could just look at the screen to\nsee whether the right tickets were appearing in the right places.  But\nwe can\'t tell whether we\'re setting the global `ticket_cost` variable\ncorrectly.\n\nTemporarily, we will *show* this variable once we\'ve set it, just to\nbe able to test our program.  In Scratch we would either tick the box\nnext to the variable, or include the block\n\n```scratch\nshow variable [ticket-cost v]\n```\n\nin a script.  In Pytch, we\'ll add this line to the `choose_ticket()`\nmethod:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n\n\nUsing `None` for the first argument to `show_variable()` means that we\nwant to show a global variable.\n\nIf you now run your program (by clicking the green flag), and click on\none of the tickets, you should see the correct `ticket_cost` shown in\nthe watcher at the top-left of the stage.\n\n(As an experiment, temporarily take out, or comment out, the `global\nticket_cost` line.  Try to predict what will happen when you click on\na ticket.  Then run the code and see if you were right.  Put the line\nback after you have investigated this.)\n\nIt\'s a good idea to do the test for each of the three tickets, to make\nsure everything\'s working.\n\nOnce you\'re happy, take out the `show_variable()` line again:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n\n\n\n', ' Show only the chosen ticket\n\nWe need to give some feedback to the customer once they have clicked\non the ticket they want.  We\'ll make the other ticket clones\ndisappear, leaving just the chosen one.\n\nFirst we will write the method that does this, and then make it happen\nwhen a ticket is chosen.  The question is:\n\n* How does a clone know whether it is the chosen one?\n\nBy the time our program has to ask this question, the global\n`ticket_cost` variable will be set to the cost of the chosen ticket.\nSo each clone can compare its own cost to the chosen cost.  If they\'re\nthe same, that clone was the chosen one.  Flipping this round, a\n`Ticket` clone is *not* the chosen one if its own cost is *not equal\nto* the chosen ticket\'s cost.  In code, this test is\n\n    self.cost != ticket_cost\n\nbecause `!=` is the Python operator for \'not equal to\'.\n\nWe can now write the code which hides a ticket clone if it is not\nthe chosen one:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n\n\nWhat do you think will happen now if you run your program and click on\na ticket?  Try it and see, then read on.\n\nThe program does in fact *not* yet hide the other tickets, because we\nhave not said when we want our new `hide_if_not_chosen()` method to\nrun.  It is exactly as if we had built this Scratch script:\n\n```scratch\nif <not <(cost) = (ticket-cost) >> then\nhide\n```\n\nbut not put a \'hat block\' on top.\n\nWe\'ll fix this now, by using a broadcast message.  When a ticket is\nchosen, it will broadcast a message, which we will make *all ticket\nclones* listen for with a `when_I_receive()` decorator:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n\n\n', ' Test the code!\n\nRun the code now to check it does what it should.  To be thorough,\ncheck that the program works correctly for all choices of ticket.\n\n\n', ' Move the chosen ticket into the corner\n\nTo make room to show the coins and note, we will animate the chosen\nticket into the corner of the stage.  We can do this within the same\n`hide_if_not_chosen()` method, by adding an `else` clause saying what\nto do if the clone *is* the chosen one:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nThe *x* number (`135`) and *y* number (`125`) here took some\nexperimenting to make the ticket go to a sensible place.  You can\nadjust them if you prefer the ticket to be a bit closer to or further\nfrom the corner of the stage.  Experiment until you\'re happy with how\nit looks.\n\nWhat would happen if you changed the third number (`0.75`) in this\ncode?  Try it and see.\n\nWe\'ve now completed the first part of the task: The customer can\nchoose the ticket they want.  Next we\'ll let the customer insert coins\nor notes to pay for their ticket.\n\n\n', ' Add a Sprite for the money\n\nTo show the different sorts of money (two coins and one note), we can\nuse the same ideas that we used for the tickets.  First we will add a\nSprite for the money, giving it three costumes:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n\nThere will be a problem if you run your program now, though.  Can\nyou predict what will go wrong?\n\nThe problem is that a €1 coin will be in the middle of the stage, in\nthe way of the adult ticket.  To fix this, we need to make the `Money`\nsprite hide itself when the simulation starts:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n\nOur next job will be to write code to show the money at the right\ntime.\n\n\n', ' Show the different sorts of money\n\n![Money types in row](money-types-in-row.png', 'img-float-right)\n\nTo show the different sorts of money (two coins and one note), we can\nre-use the ideas we used for showing the ticket types.  Copying the\nway that code did it, we add a method `show_money()` to our `Money`\nsprite.  The method sets costumes, moves, and makes clones exactly as\nthe `Ticket` sprite did.  This time, we\'ll arrange the money\nhorizontally across the centre of the stage, as shown to the right:\n\nBecause we\'ve done this before, here is the code all in one piece:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.go_to_xy(120, -50)\n\n\nWe have *not* yet put a decorator (\'hat block\') on this method,\nbecause we first need to think about this question:\n\n* When should the money appear?\n\nAnd the answer is that it should appear once the chosen ticket has\nfinished moving to the corner.  We can give the `Ticket` sprite\'s\n`choose_ticket()` method the job of sending a message for the `Money`\nsprite to respond to.  First we go back to the `Ticket` sprite and add\ncode to broadcast a suitable message:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.go_to_xy(120, -50)\n\n\nAnd we also tell Pytch that the `show_money()` method inside our\n`Money` sprite should run when it hears this message:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.go_to_xy(120, -50)\n\n\n', ' Test the code!\n\nRun the program now, choose a ticket, and check that the money appears\nin the right place once the chosen ticket has moved to the corner.\n\n\n', ' Make each Money clone know its value\n\nEach `Money` clone needs to know the value of the coin or note it\nrepresents.  This is a very similar problem to when we had to make\nsure each `Ticket` clone knew how much it costs.  So we will give each\n`Money` clone a `value` variable, set to the number of euro it\'s worth:\n\nimport pytch\n\n\nticket_cost = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n\n\n\n', ' Track money received\n\nWe now need to let the customer click on the coins or note, and keep\ntrack of how much money (in euro) the machine has received from the\ncustomer.  A global variable — `money_received` — will let us do this.\nWe\'ll declare it near the top of our program.  When the program starts\nrunning, no money has been received, so we initialise the variable to\nzero:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n\n\nWhen a `Money` clone is clicked, it should increase this\n`money_received` variable by the clicked clone\'s own `value`.  In\nScratch, we could use a \'change variable\' block, like:\n\n```scratch\nchange [money-received v] by (value)\n```\n\nIn Python, we can use the `+=` operator, which does the same job.\nRemember we need to declare `global money_received` to tell Python we\nwant to update a global variable.\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n\n\nWe\'re now facing another familiar problem — we don\'t know whether our\ncode is working, because we can\'t see the value of the\n`money_received` variable.  As earlier, we\'ll *show* this variable,\nafter we\'ve arranged the `Money` clones correctly in the\n`show_money()` method:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n\n\nBefore, we took this code out once we were happy the rest of the code\ncode was working, but this time we\'ll leave the `money_received`\nvariable shown, to simulate the machine having a display showing how\nmuch money has been received.\n\n', " Test the code!\n\nClick the green flag to run your program, then choose a Ticket.  Now\ncheck the `money_received` display updates correctly as you click on\nthe coins or note.  Each time you click on a coin or note, the display\nshould update by the right amount.\n\nHave we finished the whole task now?  If not, what's the next step?\n\n\n", " Planning: Detect when enough money received\n\nWe've mostly done the second part of the task — the customer can pay\nfor their ticket.  But it isn't quite done yet.  As the program is\nnow, the customer keeps putting in more and more money and never gets\ntheir ticket or their change.\n\nWe need our program to check whether the amount of money received is\nat least as much as the cost of the chosen ticket.  The only place\nthat this can become true is just after the customer has inserted more\nmoney.  So we can add code to the `insert_money()` method of the\n`Money` sprite to check whether the customer has now paid enough.\n\nWhat do we want to happen when the customer has inserted enough money?\n\n* Our program should work out how much change the customer needs —\n  this can be zero if the customer has inserted exactly the right\n  amount of money.\n\n* The display of `money_received` should disappear, and be replaced\n  with a display of how much change the customer is owed.\n\n* The `Money` clones should all disappear.\n\nThink about how you can check whether the customer has given the\nmachine enough money, and how you can make the above things happen,\nbefore reading on.\n\n\n", ' Compute amount of change needed\n\nOne way to do this will be to use a new variable to store the amount\nof change needed.  We\'ll declare this at the top of our program,\ninitialising it to `None` because when the program starts running, we\ndon\'t know how much change will be needed.\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\nchange_needed = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n\n\nAnd now we can add the `if` logic.  We need to ask the question\n\n* Has enough money been received?\n\nIn terms of the variables of our program, we ask\n\n* Is `money_received` greater than (or equal to) `ticket_cost`?\n\nIn Scratch, you cannot ask \'greater than or equal to\' in one step.\nYou would have to use one of these two pieces of code:\n\n```scratch\nnot <(money-received) < (ticket-cost)>\n< < (money-received) > (ticket-cost) > or < (money-received) = (ticket-cost) > >\n```\n\nPython has the `>=` operator to mean \'greater than or equal to\', so we\ncan translate the question into Python code as\n\n    if money_received >= ticket_cost:\n        ', ' ... Code to run if enough money has been inserted ...\n\nThe first task from our list above is to work out the amount of change\nneeded.  To find this, we subtract the cost of the ticket from the\namount of money received — for example, if the ticket is €6 and the\ncustomer has given us €10, they need €10−€6=€4 change.  In code, this\nwill be\n\n    change_needed = money_received - ticket_cost\n\nbut again we need to make sure Python knows we\'re talking about the\n*global* `change_needed` variable.  Putting this all together, we\'ll\nadd in the `if` statement, starting with the code to compute the\namount of change needed:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\nchange_needed = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n        if money_received >= ticket_cost:\n            global change_needed\n            change_needed = money_received - ticket_cost\n\n\nThe next task is \'replace display of money-received by display of\nchange-needed\'.  It is cleanest to do this by hiding the\n`money_received` variable and then showing the `change_needed`\nvariable.  We add code inside the `if` statement:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\nchange_needed = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n        if money_received >= ticket_cost:\n            global change_needed\n            change_needed = money_received - ticket_cost\n            pytch.hide_variable(None, "money_received")\n            pytch.show_variable(None, "change_needed")\n\n\n(It would work to do these two things in the other order, but it\'s\ncleaner to take away the old display before adding the new one.)\n\nFinally, we need to hide all the money clones.  We do this with a\nbroadcast message, since we want *all* clones to hide, not just the\none which was just clicked on.  First we define the method on `Money`\nwhich will make each clone hide:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\nchange_needed = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n        if money_received >= ticket_cost:\n            global change_needed\n            change_needed = money_received - ticket_cost\n            pytch.hide_variable(None, "money_received")\n            pytch.show_variable(None, "change_needed")\n\n    def hide_money(self):\n        self.hide()\n\n\nand then tell Pytch to run this method when the sprite receives a\nsuitable message:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\nchange_needed = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n        if money_received >= ticket_cost:\n            global change_needed\n            change_needed = money_received - ticket_cost\n            pytch.hide_variable(None, "money_received")\n            pytch.show_variable(None, "change_needed")\n\n    @pytch.when_I_receive("hide-money")\n    def hide_money(self):\n        self.hide()\n\n\nand finally broadcast that message as the last task once we know\nenough money has been received:\n\nimport pytch\n\n\nticket_cost = None\nmoney_received = 0\nchange_needed = None\n\n\nclass Ticket(pytch.Sprite):\n    Costumes = ["child.png", "adult.png", "family.png"]\n\n    @pytch.when_green_flag_clicked\n    def show_tickets(self):\n        self.switch_costume("child")\n        self.cost = 6\n        self.go_to_xy(0, 120)\n        pytch.create_clone_of(self)\n        self.switch_costume("adult")\n        self.cost = 10\n        self.go_to_xy(0, 0)\n        pytch.create_clone_of(self)\n        self.switch_costume("family")\n        self.cost = 20\n        self.go_to_xy(0, -120)\n\n    @pytch.when_this_sprite_clicked\n    def choose_ticket(self):\n        global ticket_cost\n        ticket_cost = self.cost\n        pytch.broadcast_and_wait("hide-non-chosen")\n        pytch.broadcast_and_wait("show-money")\n\n    @pytch.when_I_receive("hide-non-chosen")\n    def hide_if_not_chosen(self):\n        if self.cost != ticket_cost:\n            self.hide()\n        else:\n            self.glide_to_xy(135, 125, 0.75)\n\n\nclass Money(pytch.Sprite):\n    Costumes = ["coin-1.png", "coin-2.png", "note-5.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("show-money")\n    def show_money(self):\n        self.switch_costume("coin-1")\n        self.value = 1\n        self.go_to_xy(-165, -50)\n        self.show()\n        pytch.create_clone_of(self)\n        self.switch_costume("coin-2")\n        self.value = 2\n        self.go_to_xy(-45, -50)\n        pytch.create_clone_of(self)\n        self.switch_costume("note-5")\n        self.value = 5\n        self.go_to_xy(120, -50)\n        pytch.show_variable(None, "money_received")\n\n    @pytch.when_this_sprite_clicked\n    def insert_money(self):\n        global money_received\n        money_received += self.value\n        if money_received >= ticket_cost:\n            global change_needed\n            change_needed = money_received - ticket_cost\n            pytch.hide_variable(None, "money_received")\n            pytch.show_variable(None, "change_needed")\n            pytch.broadcast_and_wait("hide-money")\n\n    @pytch.when_I_receive("hide-money")\n    def hide_money(self):\n        self.hide()\n\n\n\n', ' Test the complete program\n\nThink about how you can thoroughly test your program.  Does it always\ncompute the right amount of change?  Does it work if you give the\nmachine the exact money, as well as too much money?  What other ways\ncan you test it?\n\n\n', ' Questions and challenges\n\nHere are some questions to investigate, and also some ideas you could\nuse to make the program better.  Can you think of others?\n\n', " Investigate: Sequencing techniques\n\nThis program uses two ways of making things happen in the right\nsequence:\n\n* Within a single method, we just arrange the Python statements in the\n  sequence which will give the right result.  A good example of this\n  is the care we had to take when creating the `Ticket` clones while\n  moving, changing costumes and storing each one's cost.\n\n* The major parts of the program — choose ticket, insert money,\n  display change — were sequenced by responding to the user's clicks,\n  and by broadcasting and receiving messages.\n\nWhich do you find easier to think about?  When might you have to use\none particular technique?  Are there other ways of sequencing\ndifferent parts of a program?\n\n", ' Investigate: Interaction with the user\n\nIf you have done other Python programming, you might have seen\nprograms which use Python\'s built-in `input()` function.  For example,\nallowing the user to choose a ticket type might be done with code like\n\n    print("What ticket type?")\n    chosen_ticket = input("[C]hild, [A]dult, or [F]amily? ")\n\nIn our program, the user instead chooses a ticket type by clicking.\n\nWhich is easier for the user?  Which is easier for you, the\nprogrammer?\n\n', " Investigate: Knowing which is the chosen ticket\n\nIn the `Ticket` method `hide_if_not_chosen()`, each clone decides\nwhether it's the chosen ticket based on whether its own cost is equal\nto the chosen ticket's cost.  If there were different tickets at the\nsame price (for example, a student ticket also costing €6), this would\nnot work.\n\nA different way would be to give each clone a `was_chosen` variable,\nand assign `False` to it at the very start of the method\n`show_tickets()`.  Then, in the method `choose_ticket()` (which runs\nfor a particular clone when that clone is clicked), you would assign\n`True` to that clone's copy of `was_chosen`.  Finally, inside\n`hide_if_not_chosen()`, the `if` statement would become\n\n    if not self.was_chosen:\n        self.hide()\n    else:\n        self.glide_to_xy(135, 125, 0.75)\n\nTry making this change.  Which approach do you prefer?  Would the `if`\nstatement be clearer (to a human reader of the program) the other way\nround —\n\n    if self.was_chosen:\n        self.glide_to_xy(135, 125, 0.75)\n    else:\n        self.hide()\n\n— instead?\n\n", " Improvement: Simulate dispensing the ticket\n\nWhen the customer has inserted enough money, our vending machine shows\nthem the change they need.  The chosen ticket stays at the top of the\nscreen.  Can you simulate giving the customer the ticket, maybe by\nsmoothly moving the ticket to the centre of the screen?  Experiment\nwith the sequencing of hiding the coins and note, hiding the 'money\nreceived' display, showing the change, and dispensing the ticket.\nWhich sequence looks best?\n\n", ' Improvement: Show the change in coins\n\nInstead of just showing the change as a number, show the coins that\nthe customer should get back.  The most change a customer will ever\nneed is €4.  (Can you see a good argument why this is true?)  So it\nwill be easiest to just write code for each of the four cases where\nchange is needed (€1, €2, €3, €4), rather than try to work out a\ngeneral change-giving algorithm.\n\n', ' Improvement: Add sound effects\n\nFind some suitably-licensed sounds on the web for clicking buttons,\ninserting money, accepting money, and so on.  Add them to the project,\nand play the sounds at appropriate times in the program.  You can use\nthe Pytch methods\n\n    self.start_sound("button-click")\n\nand/or\n\n    self.play_sound_until_done("coin-insertion")\n\nto do this.\n', ' Boing: Make a Pong-like game\n\nIn this tutorial we will make a version of the classic game\n[Pong](https://en.wikipedia.org/wiki/Pong).  We are going to use the graphics,\nand some of the ideas, kindly made available by the [Code the\nClassics](https://wireframe.raspberrypi.org/books/code-the-classics1) book\npublished by the Raspberry Pi organisation.\n\n\n---\n\n', ' Make the playing area\n\nWe first set up the _Stage_, which, like Scratch, is where the action takes\nplace.  We\'re going to use the same image as the version in _Code the Classics_.\nWe define a `class` which is based on the built-in `pytch.Stage`, and say what\n_Backdrops_ we want it to have.  In Pytch we can do this by giving a _list_ of\nbackdrop filenames.  Here we only have one backdrop, so our list just has one\nentry.\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\n\n', ' Add the player\'s bat\n\nNow we have the background, we want to put the player\'s bat into the\ngame.  The first part of this is similar to how we introduced the\n_BoingBackground_.  We define _PlayerBat_, which we say is a kind of\n_Sprite_.  Again, its _Costumes_ list only has one entry.\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n\nWhen the green flag is clicked, we want the player\'s bat to go to its\nstarting position:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n\nOnce the game has started, the person playing the game needs to be\nable to move the bat.  We do this by continually checking whether the\nperson is pressing the `W` key to move up, or the `S` key to move\ndown.  If they are, we change the bat\'s _y_ coordinate:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w"):\n                self.change_y(3)\n            if pytch.key_pressed("s"):\n                self.change_y(-3)\n\n\nIf you play the game now, you\'ll see a problem.  You can move the bat\nright off the top of the stage.  To stop this, we\'ll only move if\nyou\'re pressing `W` and you\'re low enough that moving up is allowed.\nWe\'ll make the same change to the \'move down\' part of the code:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\n\n', ' Add the ball\n\nThe next thing to add is the ball.  We do this in a very similar way\nto how we added the player\'s bat.  The ball only has one costume, and\nwe tell Pytch which file to use:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n\nWhen the green flag is clicked, the ball should go to the very centre\nof the screen:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n\nThen it should straight away start moving away from the player, to\ngive them time to get ready.  We do this by continually changing the\nball\'s _x_ coordinate:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        while True:\n            self.change_x(3)\n\n\nThe problem here is that the ball of course just keeps going right\noff the edge of the screen.  We know we\'re going to need to keep track\nof which direction the ball is going, so we bring in a *local variable*\n`x_speed`.  This variable only exists inside the `play()` method.\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n\nWe\'ll leave the ball here until there is a robot bat for the player to\nplay against, which is what we\'ll do next.\n\n\n', ' Add the robot opponent\n\nThis is familiar by now.  We add _RobotBat_, which is a sort of\n_Sprite_, with a costume:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n\nWhen the green flag is clicked, the robot bat will go to the right\nplace on the screen, which is at the right, vertically centred:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n\nShortly we\'ll give the robot bat some intelligence, but next we\'ll\nreturn to making the ball bounce.\n\n\n', ' Bounce the ball off the bats: simple version\n\nThe ball can tell if it\'s moved far enough to the right that it should\nbounce off the robot.  Straight after the ball has moved, we want\ncheck if it\'s moved too far.  If it has, we want to move _back_ the\nsame amount we just moved, and then change our `x_speed` to be the\n_opposite_ of what it just was:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n\nWe can do the same to make the ball check if it\'s bounced off the\nplayer\'s bat:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n\nIf you run this now, it looks good but boring.  The ball just bounces\nbackwards and forwards between the player and the robot.  But!  If you\nmove the player up or down, you\'ll see that the ball bounces even it\nthe player misses it.  We\'ll fix this next.\n\n\n', ' Bounce properly off the player\'s bat\n\nWhat we want to do is measure how far up or down on the player\'s bat\nthe ball has hit, if it hits the bat at all.  We\'ll call the centre of\nthe bat \'zero\', with positive positions towards the top of the bat,\nand negative positions towards the bottom.  We can work this out by\nfinding the vertical position — the _y_ coordinate — of the player\'s\nbat, and subtracting that from the ball\'s _y_ coordinate:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n\nBy experimenting with the \'45\' in the following code, we can see what\na fair number to use so the ball bounces when it looks like it should\nbounce, and misses when it looks like it should miss.  The ball only\nbounces if the position on the bat is \'higher than the bottom of the\nbat\' and also \'lower than the top of the bat\':\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n\n\nThis is better.  The ball bounces when it should, but if the player is\ntoo high or too low, the ball sails right past, off to the left.  But\nthis does not make for an interesting game.\n\nWe\'ll make the ball bounce off in different directions, depending\nwhere on the bat the player hits it.  If the player hits the ball with\nthe top of their bat, the ball will bounce off upwards, and similarly\nfor the bottom of their bat.\n\nTo let us work with this, the ball needs to remember how quickly it\'s\nmoving _vertically_, i.e., in the _y_ direction.  So we add another\nlocal variable, `y_speed`.  It starts off as zero, because the ball is\nmoving neither up nor down, just straight across:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n\n\nEvery step, the ball should change its _y_ position by this amount:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n\n            self.change_y(y_speed)\n\n\nAt the moment this makes no difference, because changing something by\nzero leaves it alone.\n\nWe can now make the ball fly off in different directions, depending on\nwhere on the bat the player hit it.  We worked out that the \'position\non bat\' goes from about `-45` at the bottom to `45` at the top.\nWe\'ll divide this by ten to get the ball\'s new _y_-speed, but ignoring\nany remainder by telling Pytch to turn the answer of the division into\nan _integer_ (whole number) using `int()`:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n\n            self.change_y(y_speed)\n\n\nIf you try this now, you can check that the ball bounces off the\nplayer\'s bat as it should.  But the ball then just keeps flying off\nthe top or bottom of the screen.\n\n', ' Bounce the ball off the top and bottom of the court\n\nWe can tell if the ball has gone too high or too low by comparing its\n_y_ coordinate to numbers chosen by experiment.  If it has gone too\nhigh or too low, we undo the last _y_ change, and make the _y_-speed\nbe the opposite of what it was:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\nIf you play the game now, it sort of works, but there are two obvious\nproblems:\n\n* The ball keeps going past the player\'s bat if you miss and then\n  after a short while mysteriously re-appears.\n\n* The robot player never moves but still the ball bounces off the\n  right-hand edge of the screen.\n\nWe\'ll fix these things next.\n\n\n', ' End the game if the player misses\n\nThe code we added to bounce the ball off the player\'s bat checked if\nthe _position on the bat_ was not too high or too low, and then\nbounced the ball if it was OK.  But it did nothing if the ball _was_\ntoo high or too low.  We need to add an `else` clause, saying that if\nthe player misses, that\'s the end of the game.  The ball should hide,\nand we `break` out of the `while True` loop, to finish the game:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                else:\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\nThis is better, but looks odd because the ball just vanishes.  We can\nfix this by moving the ball for another few steps once we know the\nplayer has missed it:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\n(This still isn\'t quite right if the ball should bounce vertically,\nbut we\'ll ignore that.)\n\n\n', ' Move the robot\'s bat automatically\n\nReturning to the robot player, at the moment it just moves to the\ncentre at the start of the game and stays there.  We want it to then\nkeep its vertical position (_y_ coordinate) matching the ball\'s.  This\nwill make it follow the ball up and down:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\nThis is much better, but still not quite right.  The robot can go off\nthe top of the court or off the bottom.  If moving to the ball\'s\nposition has taken the bat off the top of the court, we set the bat to\nbe at the top of the court instead.  And similarly for the bottom:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\n\n', ' Make some noise\n\nWe want to bring in some sounds for the game:\n\n* Different bounce noises for bouncing off a bat compared to the top\n  or bottom of the court.\n\n* Make a sound when the player loses.  (The robot never loses!)\n\nWe define these in a similar way to costumes.  We say what the\n`Sounds` for a sprite are.  We say which filename each sound comes\nfrom:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\nTo make the \'a bat hit the ball\' sound, we start the `hit` sound just\nafter changing the ball\'s `x_speed`, which we do here for if it hits\nthe robot\'s bat:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\nand here if the ball has bounced off the player\'s bat:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n\n\nIf the ball bounces off the top or bottom of the court, we start the\n`bounce` sound straight after flipping the ball\'s `y_speed`:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\nAnd we can start the `lost` sound once the ball has gone past the\nplayer\'s bat and hidden itself:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\n\n', ' Add effects when a bat hits the ball\n\nTo make the game look better, we\'ll add a flash effect when either the\nplayer or the robots hits the ball.  We\'ll need to add a costume to\nthe player bat Sprite:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\nNext we say how we want the flash to happen.  We want to switch to the\n`hit-flash` costume, wait a short time, then switch back to `normal`.\nWe\'ll do this when the player\'s bat sprite receives a message\n`player-hit`:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\nTo make this actually happen, we want to broadcast that message when\nthe ball bounces off the  player\'s bat:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\nNow we do something very similar for the robot.  First add a costume:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png", "robot-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\nDefine what needs to happen to make the robot bat flash:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png", "robot-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n    @pytch.when_I_receive("robot-hit")\n    def flash_briefly(self):\n        self.switch_costume("robot-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("robot-normal")\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\nAnd then trigger this action when the ball bounces off the robot\'s\nbat:\n\nimport pytch\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png", "robot-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n    @pytch.when_I_receive("robot-hit")\n    def flash_briefly(self):\n        self.switch_costume("robot-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("robot-normal")\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                pytch.broadcast("robot-hit")\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\n\n', ' Avoid a stalemate\n\nThe game can get \'stuck\' with the ball bouncing just straight left and\nright between the bats.  This is boring.  We\'ll make it so that if the\nball bounces off the robot bat and is going purely horizontally, we\'ll\nchange it to go either gently up or gently down at random.\n\nTo do this, we need to use the random number part of Pytch, by\nbringing in the `random` module:\n\nimport pytch\nimport random\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png", "robot-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n    @pytch.when_I_receive("robot-hit")\n    def flash_briefly(self):\n        self.switch_costume("robot-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("robot-normal")\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n                pytch.broadcast("robot-hit")\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\n(This is very similar to how you "add an extension" in Scratch to\nmake more blocks available.)\n\nNow we have this, we can test if the ball\'s `y_speed` is zero, and if\nso, use the `random.choice()` function to make Pytch randomly choose\nbetween the two `y_speed` values we want:\n\nimport pytch\nimport random\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png", "robot-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n    @pytch.when_I_receive("robot-hit")\n    def flash_briefly(self):\n        self.switch_costume("robot-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("robot-normal")\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n                if y_speed == 0:\n                    y_speed = random.choice([-1, 1])\n\n                pytch.broadcast("robot-hit")\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\n\n', " Add instructions\n\nTo tell the player how to use our game, we'll add some instructions at\nthe top of our code.  We'll do this using a Python *comment*, which is\na part of your program meant just for human readers — Python ignores\nit.  In Python, a line starting with the `", '` character is a comment.\nWe\'ll add a short comment explaining how to play Boing:\n\n# You\'re the player on the left --- use the W/S keys to move your bat!\n\nimport pytch\nimport random\n\n\nclass BoingBackground(pytch.Stage):\n    Backdrops = ["table.png"]\n\n\nclass PlayerBat(pytch.Sprite):\n    Costumes = ["player-normal.png", "player-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(-215, 0)\n\n        while True:\n            if pytch.key_pressed("w") and self.y_position < 117:\n                self.change_y(3)\n            if pytch.key_pressed("s") and self.y_position > -117:\n                self.change_y(-3)\n\n    @pytch.when_I_receive("player-hit")\n    def flash_briefly(self):\n        self.switch_costume("player-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("player-normal")\n\n\nclass RobotBat(pytch.Sprite):\n    Costumes = ["robot-normal.png", "robot-flash.png"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(215, 0)\n\n        while True:\n            target_y = Ball.the_original().y_position\n            if target_y < -117:\n                target_y = -117\n            if target_y > 117:\n                target_y = 117\n            self.set_y(target_y)\n\n    @pytch.when_I_receive("robot-hit")\n    def flash_briefly(self):\n        self.switch_costume("robot-flash")\n        pytch.wait_seconds(0.1)\n        self.switch_costume("robot-normal")\n\n\nclass Ball(pytch.Sprite):\n    Costumes = ["ball.png"]\n    Sounds = ["hit.mp3", "bounce.mp3", "lost.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def play(self):\n        self.go_to_xy(0, 0)\n\n        x_speed = 3\n        y_speed = 0\n        while True:\n            self.change_x(x_speed)\n\n            if self.x_position > 203:\n                self.change_x(-x_speed)\n                x_speed = -x_speed\n\n                if y_speed == 0:\n                    y_speed = random.choice([-1, 1])\n\n                pytch.broadcast("robot-hit")\n                self.start_sound("hit")\n\n            if self.x_position < -203:\n                player_y = PlayerBat.the_original().y_position\n                position_on_bat = self.y_position - player_y\n                if (position_on_bat >= -45) and (position_on_bat <= 45):\n                    y_speed = int(position_on_bat / 10)\n                    self.change_x(-x_speed)\n                    x_speed = -x_speed\n                    pytch.broadcast("player-hit")\n                    self.start_sound("hit")\n                else:\n                    for i in range(10):\n                        self.change_x(x_speed)\n                        self.change_y(y_speed)\n                    self.hide()\n                    self.start_sound("lost")\n                    break\n\n            self.change_y(y_speed)\n\n            if self.y_position > 158 or self.y_position < -158:\n                self.change_y(-y_speed)\n                y_speed = -y_speed\n                self.start_sound("bounce")\n\n\n\n', " Challenges\n\nHere are some ways you could make the game better.  Both of these\ntasks are quite advanced, so your first step should be to think about\nhow to break the job down into manageable pieces.\n\n* At the moment, the human player has no chance against the computer.\n  Can you make it so the computer does *not* always win?\n\n* At the moment, the game stops once the player misses the ball.  Can\n  you instead keep score, and make it so the winner is the first to\n  get ten points?  This only makes sense if you've already made it so\n  the computer sometimes misses!\n\nYou could also experiment with changing the physics of the game, for\nexample:\n\n* Add gravity, so the ball falls towards the bottom of the screen.\n  Think about how the `y_speed` of the `Ball` sprite needs to change\n  to give the right effect.\n\nCan you think of other changes or improvements?\n\n\n", ' Credits\n\nMany thanks to the Raspberry Pi Press for making the contents of their\n*Code The Classics* book available under a Creative Commons licence.  We\nhave used their code for inspiration, and also the images and sounds.\n\n', ' Detailed credits\n\n{{< asset-credits >}}\n', ' Trimon\n\nWe’ll make a memory game where the player has to remember longer and\nlonger patterns of flashing lights.  Don’t get one wrong!\n\n\n---\n\n', ' Creating the backdrop\n\nWe’ll start by adding a Stage with a simple blue gradient backdrop:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nIf you run your program after adding these lines, you should see the\nbackground.\n\n\n', ' Making the first light\n\nOur game will have three lights.  We’ll start by adding just one of\nthem.  Once we have that working, we’ll copy and paste the code, with\nsmall changes, to make the other lights.  (This isn’t usually the best\nway to make a set of similar things, but the other ways are more\nadvanced than we can cover in this tutorial.)\n\nThe light is called an ‘LED’ in the code, because that’s the sort of\nlight the image looks most like.  It needs two costumes, one for when\nit’s just sitting there, and another for when it’s lit up:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n\n\nWe want to arrange the LEDs in a line across the screen, so at the\nstart of the game, this LED should move to a position a bit to the\nleft of centre, and a bit above centre:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n\nThe light should be able to make a noise, so we’ll add a sound:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n\nAnd finally (for now), we’ll make the light flash and make its sound\nwhen we click on it:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nI’m saying which costume to switch to based on position in the list,\nwhere the first thing in the list is position zero.  You could use the\ncostume names (`"light-off"` and `"light-on"`) if you prefer.\n\n', ' Try this now!\n\nIn the final game, it won’t be clicking that sets off the flash and\nsound, but by writing this code, we can test what we’ve done so far.\nWe’ll change the code later.\n\n\n', ' Making the other lights\n\nThe other lights are fairly similar, so we’ll go through this more\nquickly.  For now we’ll just add the basics of these two.\n\nFirst the middle light.  Its costumes and sounds are very similar to\nthe left-hand light, except this light will make a different sound:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n\nThe right-hand light is also similar:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n\nAt the start of the game, the middle light should move to its\nposition:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n\nAnd the right-hand light to _its_ position:\n\nimport pytch\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n\nWe won’t bother with the testing ‘click to flash and make a noise’\ncode for these two.  We’ll put the proper code in later.\n\n\n', ' Storing the pattern in a variable\n\nNow we’ll think about how to keep track of the pattern which the\nplayer has to repeat.  We’ll give each light a number:\n\n* `1` — left-hand light\n* `2` — middle light\n* `3` — right-hand light\n\nand store the pattern in a variable holding a Python _list_, which is\nperfect for this job.\n\nSoon we’ll write the code which shows the pattern, and we want to be\nable to test that code without having to write all the rest of the\ngame.  So we’ll cheat, and start off with a short pattern.  At the top\nof the program, we’ll define a variable holding a pattern we can test\nwith:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n\nWhen we’ve written the rest of the code, this list should mean the\npattern\n\n* left, middle, right, left.\n\nplays.\n\n\n', ' Playing the pattern on the lights\n\nWe need to think about whose job it is to control the showing of the\npattern.  It involves more than one light, so we’ll put the code in\nour `Background`.\n\nThe `Background` will tell a particular light to flash by broadcasting\na message:\n\n* To tell the **left-hand** light to flash, it’ll broadcast **`"flash-1"`**.\n* To tell the **middle** light to flash, it’ll broadcast **`"flash-2"`**.\n* To tell the **right-hand** light to flash, it’ll broadcast **`"flash-3"`**.\n\nWe’ll use `broadcast_and_wait()` to make sure each light finishes its\nflash before we tell the next light to do its flash.\n\nWe want to be able to test this code, so for now we’ll make it happen\nwhen we press a key.  In the full game, this will be different.\n\nOur code should go through each number in the `pattern` list in turn,\nand broadcast the correct message.  The message should be the string\n`"flash-"` joined on to the light number.  Suppose we have a variable\n`led` which is the number `1`, `2`, or `3`.  Then we can turn that\nnumber into a string by saying `str(led)`.  We can glue the two\nstrings together with `+`, and give a name to the string we get, by\nsaying\n\n``` python\nmessage = "flash-" + str(led)\n```\n\nTo go through the numbers in the `pattern` list one by one, we can use\na useful feature of Python made for exactly this job, the\n\n``` python\nfor thing in list_of_things:\n    ', ' Do something with thing\n```\n\nloop.\n\nPutting this all together, we get:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_this_sprite_clicked\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n\nBut if you run this and try pressing `p`, nothing will happen, because\nwe haven’t told the lights to react to those messages yet.\n\n\n', ' Making the lights flash via messages\n\nWe already have working code to make the left-hand light flash and\nmake its sound.  We just need to use a different ‘hat block’, to tell\nPytch to run this code when the message `"flash-1"` is received.  So\ndelete the `when_this_sprite_clicked` line and replace it with a\n`when_I_receive` line:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n\nNow this block of code is ready to copy and paste into the code for\nthe other two lights.  First we’ll copy it into `LED2`.  There are two\nchanges:\n\n* The message it reacts to is **`"flash-2"`** (not `"flash-1"`).\n* The sound it plays is **`"note-2"`** (not `"note-1"`).\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n\nAnd for `LED3`, we copy, paste, and change:\n\n* React to message **`"flash-3"`**.\n* Play sound **`"note-3"`**.\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nIf you try the program now, our test pattern (left, middle, right,\nleft) should play when you press the `p` key.\n\nIt would look better with a small pause between each flash, so we’ll\nadd a line to the loop in `Background`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\n\n', ' Adding the buttons\n\nNext, the game needs three buttons, so the player can try to repeat\nthe patterns.\n\n', ' Left-hand button\n\nWe’ll add a sprite for each button, starting with the left-hand one:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nIt should start the game by moving to a position underneath the\nleft-hand light:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nAnd when it’s clicked, it should make the left-hand light flash and\nmake a sound.  We can do this by broadcasting the correct message:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-1")\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\n', ' Middle button\n\nThis is very similar.  The `Button2` sprite has the same costume:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-1")\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nbut moves to a different position at the start of the game:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-1")\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nand broadcasts the right message to make the middle light flash and\nmake its sound:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-1")\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-2")\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\n', ' Right-hand button\n\nWe can now copy and paste and make small changes to get the code for\nthe right-hand button, `Button3`.  Watch out for the coordinates given\nto `self.go_to_xy()`, and the message given to\n`pytch.broadcast_and_wait()`.\n\nimport pytch\n\npattern = [1, 2, 3, 1]\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-1")\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-2")\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-3")\n\n\n\n', ' Stopping the player from mashing buttons\n\nIf you try the game now and are quick enough, you can click the\nbuttons quickly and make more than one light flash at once.  This\nshouldn’t happen.\n\nThe program needs to be able to tell when a light is in the middle of\nflashing, and not flash another light until that flash has finished.\n\nWe’ll keep track of that in a variable which stores the true/false\ninformation\n\n> is a light in the middle of flashing?\n\nSeveral places in the program need to use this variable, so we’ll make\nit _global_ by defining it outside any sprites.  At the start of the\ngame, no light is flashing, so the variable holds `False`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-1")\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-2")\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-3")\n\n\nStarting with the when-clicked script for `Button1`, we’ll set the\nvariable to `True` just before the broadcast-and-wait of `"flash-1"`,\nand `False` again afterwards.  We need to tell Python that we’re\ntalking about the _global_ `light_flashing` variable:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-2")\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-3")\n\n\nAnd then, `return` early if a light is already flashing:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-2")\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-3")\n\n\nWe do the same thing in `Button2`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        pytch.broadcast_and_wait("flash-3")\n\n\nand `Button3`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        light_flashing = False\n\n\n(If you’re thinking ‘surely there’s a better way to write this program\nthan copying and pasting everything’, you’re right, but the techniques\nyou need are more advanced than this tutorial covers.)\n\n\n', ' Recording the player’s attempt\n\nAs the player clicks the buttons to try to repeat the pattern, our\nprogram needs to remember the sequence of buttons in the player’s\nattempt.\n\nA global variable holding a list will do this for us.  At the start of\nthe game, the player has not pressed any buttons, so the list is\nempty:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        light_flashing = False\n\n\nWhen each button is pressed, we want to add an element to this list,\nto build up a history of the player’s attempt to repeat the pattern.\nInside `Button1`, we tell Python we’ll be talking about the _global_\n`user_attempt` variable as well as the global `light_flashing`\nvariable:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        light_flashing = False\n\n\nand then once the `"flash-1"` message has been responded to, we\n_append_ the value `1` to the list:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        light_flashing = False\n\n\nWe do something very similar in `Button2`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        light_flashing = False\n\n\nand in `Button3`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\n\n', ' Checking whether the player is getting it right\n\nEach time the player adds to the pattern, we need to check if they’re\nright so far.  We also need to check whether they’ve now done the\nwhole pattern correctly.\n\nThis is quite a fiddly piece of code, so we’ll print some messages to\nthe `Output` tab, to check the code is behaving as we want.\n\nWe’ll start by defining a function which will run in response to a\nmessage `"check-user-attempt"`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\nIn the body of this function, want to ask the question\n\n> Is what the user has done so far correct?\n\nSuppose the user has pressed four buttons so far.  Then we want to\ncompare the `user_attempt` list to a list containing the first four\nitems in the `pattern` list.  We’ll use Python _slicing_ to extract a\nsection of a list.  We find out how many items are in the\n`user_attempt` list, and then copy that many items from the start of\n`pattern` into a local list variable `pattern_start`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\nSo we can check our code is working, we’ll print the lists we’re\ninterested in:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\nWe can now ask whether the player’s attempt is equal to the first part\nof the pattern they’re meant to be copying.  For now, we’ll print a\nmessage saying whether they’re right or wrong:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\nIf they’re right so far, we can go on to check whether they’ve in fact\ngot the whole pattern right.  We can test this by comparing the length\nof the user pattern to the length of the original pattern — if they’re\nthe same, the player has got the whole pattern right.  Again, for now\nwe just print a message if the player has got everything right:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\n', ' Checking after each button click\n\nBut our program is not yet _running_ this code, because nothing is\nbroadcasting the `"check-user-attempt"` message.\n\nEach button needs to broadcast this message after adding its number to\nthe `user_attempt` list.  We add code to `Button1`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\nand `Button2`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        light_flashing = False\n\n\nand `Button3`:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_key_pressed("p")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\n', ' Test the code\n\nYou can try this now — press `p` and check what’s printed in the\n`Output` tab as you click on the buttons.\n\n\n', ' Running the game\n\nWe can now start to replace some of our ‘just for now’ code with real\ncode.\n\nThe code which plays the pattern is currently launched by pressing the\n`p` key.  Instead, we\'ll make it run when it receives a\n`"play-pattern"` message:\n\nimport pytch\n\npattern = [1, 2, 3, 1]\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nAt the start of the game, there are no lights in the pattern, so\n`pattern` should start off as the empty list:\n\nimport pytch\n\npattern = []\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\n', ' Building up a random pattern\n\nTo be able to choose random numbers, we need to `import` Python’s\nlibrary for working with random numbers.  This is like adding an\nextension in Scratch.  We want to use the code provided in the\n`random` library:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nNow we’ll put together a function which adds a new random light to the\npattern, then makes the new pattern play.  In the next block of code,\nyou should be able to find which line:\n\n* makes sure Python knows we’re talking about the _global_ `pattern`\n  variable\n* uses the `randint()` function in the `random` library to choose a\n  random whole number between 1 and 3\n* adds that number to the end of the `pattern` list\n* broadcasts the right message to make the pattern play.\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\n', ' Extending the pattern when the player gets the old pattern right\n\nJumping back to the code which tests whether the player has got the\npattern completely right, this is exactly when we should add a new\nlight-flash to the end of the pattern.  We also need to set\n`user_attempt` to the empty list, ready to build up the player’s\nattempt at the new, longer pattern.  The `clear()` method on a list\ndoes this.\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\n', ' Starting the whole game off\n\nFinally, we start the game by broadcasting the message to add a\nlight-flash and let the player try to copy it.\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nTry this now!\n\n\n', ' Only allowing button pressing at right times\n\nYou might notice that the player can click the buttons at any time,\neven when the game is showing the player the pattern.  We’ll fix that\nnow.\n\nThere are some times in the game when pressing the buttons is allowed,\nand some times when it is not allowed.  We’ll make a global variable\nto keep track of the true/false information\n\n> is the player allowed to press a button right now?\n\nThis starts off `False`, because the player isn’t allowed to press a\nbutton until the first pattern has been played.\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nOnce the pattern has been played, the player is allowed to press the\nbuttons, to try to copy the pattern.  We tell Python we’re talking\nabout the _global_ `pressing_allowed` variable.\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nIn the `check_user_attempt()` function, if the user gets the whole\npattern right, they’re then _not_ allowed to press any buttons just\nyet.  There are two changes needed in this function:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nIf the user fails, by getting a light wrong, they’re not allowed to\npress buttons:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nSo far we’re just setting this variable to different values.  We now\nmake the `Button1`, `Button2`, and `Button3` sprites abandon their\nwhen-clicked script early if pressing is not allowed.\n\nFor `Button1`:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nand `Button2`:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nand `Button3`:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\n\n', ' Using in-game messages\n\nWatching for text being printed in the `Output` tab is not great.\nWe’ll add some in-game messages.\n\nAdd a new sprite which has a costume for each message we want to show:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n\nAt the start of the game, there is no message shown, so the `Text`\nsprite should hide itself:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.hide()\n\n\nThis sprite will flash its ‘YES!’ costume when it receives the\n`"correct"` message:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.hide()\n\n    @pytch.when_I_receive("correct")\n    def flash_yes(self):\n        self.switch_costume("YES-neon-text")\n        self.show()\n        pytch.wait_seconds(1.0)\n        self.hide()\n\n\nand show its ‘FAIL’ costume when it receives `"fail"`:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.hide()\n\n    @pytch.when_I_receive("correct")\n    def flash_yes(self):\n        self.switch_costume("YES-neon-text")\n        self.show()\n        pytch.wait_seconds(1.0)\n        self.hide()\n\n    @pytch.when_I_receive("fail")\n    def flash_fail(self):\n        self.switch_costume("FAIL-neon-text")\n        self.show()\n\n\nHere there’s no need to wait and then hide, because once the player\nhas failed, the whole game is over, so the message can stay.\n\n', ' Broadcasting the messages\n\nBack inside `check_user_attempt()`, we broadcast the `"correct"`\nmessage when the player has got the whole pattern right:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.broadcast_and_wait("correct")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.hide()\n\n    @pytch.when_I_receive("correct")\n    def flash_yes(self):\n        self.switch_costume("YES-neon-text")\n        self.show()\n        pytch.wait_seconds(1.0)\n        self.hide()\n\n    @pytch.when_I_receive("fail")\n    def flash_fail(self):\n        self.switch_costume("FAIL-neon-text")\n        self.show()\n\n\nand the `"fail"` message if they make a mistake:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        print("pattern is", pattern)\n        print("user_attempt is", user_attempt)\n        print("pattern_start is", pattern_start)\n        if user_attempt == pattern_start:\n            print("OK so far")\n            if user_attempt_length == len(pattern):\n                print("Whole pattern OK")\n                pytch.broadcast_and_wait("correct")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            print("FAIL")\n            pressing_allowed = False\n            pytch.broadcast("fail")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.hide()\n\n    @pytch.when_I_receive("correct")\n    def flash_yes(self):\n        self.switch_costume("YES-neon-text")\n        self.show()\n        pytch.wait_seconds(1.0)\n        self.hide()\n\n    @pytch.when_I_receive("fail")\n    def flash_fail(self):\n        self.switch_costume("FAIL-neon-text")\n        self.show()\n\n\nTry this now!\n\n\n', ' Tidying up\n\nNow everything is working, we can delete the `print()` lines:\n\nimport pytch\nimport random\n\npattern = []\nuser_attempt = []\npressing_allowed = False\nlight_flashing = False\n\n\nclass Background(pytch.Stage):\n    Backdrops = ["blue-gradient.png"]\n\n    @pytch.when_green_flag_clicked\n    def play_game(self):\n        pytch.broadcast("add-flash-and-play")\n\n    @pytch.when_I_receive("add-flash-and-play")\n    def add_flash_and_play(self):\n        global pattern, pressing_allowed\n        new_light = random.randint(1, 3)\n        pattern.append(new_light)\n        pytch.broadcast_and_wait("play-pattern")\n        pressing_allowed = True\n\n    @pytch.when_I_receive("play-pattern")\n    def play_pattern(self):\n        for led in pattern:\n            message = "flash-" + str(led)\n            pytch.broadcast_and_wait(message)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("check-user-attempt")\n    def check_user_attempt(self):\n        global pressing_allowed\n        user_attempt_length = len(user_attempt)\n        pattern_start = pattern[:user_attempt_length]\n        if user_attempt == pattern_start:\n            if user_attempt_length == len(pattern):\n                pytch.broadcast_and_wait("correct")\n                pytch.wait_seconds(0.25)\n                user_attempt.clear()\n                pressing_allowed = False\n                pytch.broadcast_and_wait("add-flash-and-play")\n        else:\n            pressing_allowed = False\n            pytch.broadcast("fail")\n\n\nclass LED1(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-1.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, 80)\n\n    @pytch.when_I_receive("flash-1")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-1")\n        self.switch_costume(0)\n\n\nclass Button1(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(-140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-1")\n        user_attempt.append(1)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED2(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-2.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, 80)\n\n    @pytch.when_I_receive("flash-2")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-2")\n        self.switch_costume(0)\n\n\nclass Button2(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(0, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-2")\n        user_attempt.append(2)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass LED3(pytch.Sprite):\n    Costumes = ["light-off.png", "light-on.png"]\n    Sounds = ["note-3.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, 80)\n\n    @pytch.when_I_receive("flash-3")\n    def flash(self):\n        self.switch_costume(1)\n        self.play_sound_until_done("note-3")\n        self.switch_costume(0)\n\n\nclass Button3(pytch.Sprite):\n    Costumes = ["green-button.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_to_position(self):\n        self.go_to_xy(140, -80)\n\n    @pytch.when_this_sprite_clicked\n    def press_button(self):\n        global light_flashing, user_attempt\n        if light_flashing:\n            return\n        if not pressing_allowed:\n            return\n        light_flashing = True\n        pytch.broadcast_and_wait("flash-3")\n        user_attempt.append(3)\n        pytch.broadcast_and_wait("check-user-attempt")\n        light_flashing = False\n\n\nclass Text(pytch.Sprite):\n    Costumes = ["YES-neon-text.png", "FAIL-neon-text.png"]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.hide()\n\n    @pytch.when_I_receive("correct")\n    def flash_yes(self):\n        self.switch_costume("YES-neon-text")\n        self.show()\n        pytch.wait_seconds(1.0)\n        self.hide()\n\n    @pytch.when_I_receive("fail")\n    def flash_fail(self):\n        self.switch_costume("FAIL-neon-text")\n        self.show()\n\n\nCongratulations!  See how long a pattern you can remember!\n\n\n', ' Make your own improvements\n\nHere are some ways you could change or improve the game.  Or try out\nsome ideas of your own!\n\n', ' Show the player how they’re doing\n\nAdd a variable which keeps track of how many light-flashes the player\nhas got right.  You’ll need to work out what number the variable\nshould hold at the start of the game, and when it changes.\n\nYou can show a global variable called `score` by putting code like\nthis into a green-flag script:\n\n``` python\npytch.show_variable(None, "score")\n```\n\nThe name of the variable is given as a string here.\n\n', ' Use different graphics\n\nFind some images to use instead of the lights and buttons.  You’ll\nneed to think about how to show your lights ‘lighting up’.  Maybe the\nimage could get a bit bigger, or maybe you could have characters which\njump up and down instead of lights which flash.\n\n', ' Change the layout of the game\n\nCan you think of other ways of arranging the lights and buttons on the\nstage?\n\n', " Add another light and button\n\nCan you see how to extend the code to have four lights and buttons?\nThere's a sound file `note-4.mp3` you can use if you like.\n\n", ' Change the speed of the game\n\nTo play the pattern more slowly, you can increase the `0.1` in the\n`pytch.wait_seconds(0.1)` line.\n\nTo play the pattern more quickly, you can reduce that `0.1`, or even\nget rid of the `pytch.wait_seconds()` line altogether.  But even\nwithout a `pytch.wait_seconds()`, each note will still play in full.\nTo make the game faster than that, you’ll need to think harder.\n\nHint: To cut the sound short, you could do something like\n\n``` python\nself.start_sound("note-1")\npytch.wait_seconds(0.3)\npytch.stop_all_sounds()\n```\n\ninstead of the simple `self.play_sound_until_done("note-1")`.\n\n', ' Add a time limit (advanced)\n\nAdd a timer so that the player has to press the buttons quickly\nenough.  For example, you could make it so that if the player waits\nfor more than two seconds before pressing a button, they lose.\n', " Blue Invaders\n\nIn this game we'll defend ourselves from dangerous blue invaders, by\nclicking on them.  But don't destroy the friendly green aliens by\nmistake!\n\n\n---\n\n", ' Set the backdrop\n\nOur first job is to make the background for our game.  This tutorial\nincludes a starry sky image for us to use.  We create a sort of\n`Stage`, calling it `Galaxy`, and say that it has one backdrop.  The\nname in `""`s there — `"starry-sky.jpg"` — is the name of the image\nfile.  You can check this in the *Images and sounds* tab.\n\nimport pytch\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n\nIf you add this code to your project and click the green play button,\nyou should see the game\'s background.\n\n\n', " Create the aliens\n\nFor the aliens which will drop down the screen, we are going to use a\nfeature of Pytch called *clones*.  These work the same way as clones\nin Scratch.  There will be an `Alien` Sprite which will have two\ncostumes.  When a clone is wearing one costume, it counts as an enemy\nspace invader, and when it's wearing the other costume, it's a\nfriendly visitor.\n\n", ' Create Sprite with costumes\n\nWe first make the `Alien` Sprite, and say what images we want to use\nfor its two costumes:\n\nimport pytch\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n\nIf you add this code to your project and run it, you should see a blue\nenemy invader in the middle of the screen.  This is because Pytch\nstarts a Sprite off wearing the first costume in its list.\n\n', ' Make the alien drift down the screen\n\nNext, we will make the alien move.  We\'ll make it glide from the top\nto the bottom of the screen, then instantly go back to the top and\nstart gliding again.\n\nThis should all start happening as soon as the game starts, so we\'ll\nuse `@pytch.when_green_flag_clicked` at the top of the code we\'re\nadding.  For the code itself, we want something which works the same\nas Scratch\'s *forever* block.  In Python, we use `while True:`, and\nsay what we want to keep happening in *indented* lines underneath.  We\nwant the alien to go to the top of the screen, then glide to the\nbottom.\n\nimport pytch\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_green_flag_clicked\n    def drift_down_screen(self):\n        while True:\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n\nYou\'ll see that the code uses `self.x_position` — this is the same as\nthe *(x&nbsp;position)* reporter block in Scratch.  For this original\nalien, this might seem over-complicated, because we know its\n*x*-position is zero.  But I\'m looking ahead to when there will be\nmore than one alien, each with its own *x*-position.\n\n', ' Randomly choose whether enemy or friendly\n\nSome of the aliens that drift down the screen will be enemies, and\nsome will be friendly.  Remember that this is done by making the alien\nwear a different costume.\n\nWe want the costume to be random each time.  Python can generate\nrandom numbers, but we need to say we want to use that part of Python.\nWe do this by *importing* the `random` library:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_green_flag_clicked\n    def drift_down_screen(self):\n        while True:\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n\nThis is very much like adding an extension in Scratch.\n\nAnd now we can ask for a random costume.  Just like in Scratch, we can\nswitch costume either by giving the costume\'s position in the costumes\nlist, or by giving the costume\'s name.  We\'ll choose the costume by\nposition.\n\nIn Python, things in a list are numbered from *zero*, so the first\nthing in a list is at \'position&nbsp;0\', the second thing is at\n\'position&nbsp;1\', and so on.  So we want to randomly choose either\nthe costume at position&nbsp;0 or the one at position&nbsp;1.\n\nThe `random.choice()` function will do this for us.  We want to switch\nto a random costume just before jumping back to the top of the screen:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_green_flag_clicked\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n\nThere\'s quite a lot going on in this one line of new code.  We can\nunderstand it by starting from the inside:\n\n* `[0, 1]` is a list with two things in it — the number zero and the\n  number one.\n\n* `random.choice([0, 1])` asks Python to choose randomly between the\n  two things in that list.  So the result of this piece of code is\n  either the number&nbsp;0 or the number&nbsp;1.\n\n* `self.switch_costume(random.choice([0, 1]))` makes the Alien sprite\n  switch to that randomly-chosen costume.\n\nIf you run the project now, you should see some blue enemy invaders\nand some green friendly visitors gliding down the screen.\n\nBut only one alien is on screen at a time.  We\'ll fix that next.\n\n\n', " Make lots of aliens\n\nTo make more than one alien, we're going to use *clones*.  These work\nthe same as in Scratch — you get more than one copy of the same\nsprite.  This is perfect for what we're trying to do.\n\nTo make sure that everything happens in the right order, we're going\nto use another part of Pytch which might be familiar from Scratch —\n*broadcasts*.  A sprite can 'shout' a message, and any sprite\n(including the same sprite that shouted!) can be listening for that\nmessage, and run some code whenever the sprite hears the message.\n\n", ' Write code to create five clones\n\nWe\'ll first write some code which clones the Alien five times.\nTogether with the original Alien, this will give us six aliens.  I\nworked out what *x*-positions spread the aliens left to right across\nthe screen: -150, -90, -30, 30, 90, 150.  The idea now is to move the\noriginal Alien to one of those places, make a clone, then move on to\nthe next place.  We\'ll make all of this happen when somebody\nbroadcasts the message `"make-clones"`.\n\nThis adds up to quite a lot of code:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_green_flag_clicked\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n\nWe\'ll see later how to avoid repeating ourselves like this.\n\n', ' Broadcast the message to run that code\n\nWe\'ll put the *Galaxy* stage in charge of broadcasting the\n`"make-clones"` message.  This next bit of code needs to be added to\nthe `Galaxy` not the `Alien`:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_green_flag_clicked\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n\n\nIf you run the game now, it doesn\'t really work.  We do get some more\naliens at the top of the screen, but only one of them is gliding\ndown.  This is because the `drift_down_screen()` code starts running\nbefore the `make_clones()` code has finished.  We need to make sure\nthings happen in the right order — we\'ll fix this next.\n\n', ' Wait for all clones to exist before gliding\n\nThe code we just added uses `broadcast_and_wait()`.  Just like in\nScratch, your program doesn\'t go on to the next statement until\neverybody listening for the `"make-clones"` message has finished doing\nwhatever it is they do when they hear it.  So if we add code after\n`broadcast_and_wait()`, we know that all the clones will exist when\nthat code runs.\n\nWe\'ll use this to change when the aliens start gliding.  First, we\'ll\nsay that the `drift_down_screen()` code in the `Alien` sprite should\nhappen when an alien or clone hears a `"play-game"` message (and not\nwhen the green flag is clicked).  This is like when, in Scratch, you\nget rid of a script\'s hat block and attach a different one.\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n\n\n(The red and green lines here mean that you delete the old code (red\nbackground, with `-` at the left), and add in its place the new code\n(green background, with `+` at the left).  Quite a lot of the old line\nis still in the new line, so you can just delete `green_flag_clicked`\nand replace it with `I_receive("play-game")` if you\'re careful!)\n\nAnd then we\'ll make the `run()` code in `Galaxy` broadcast that\nmessage, after the clones have all been created:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nIf you run the code now, you should see waves of aliens gliding down\nthe screen, with a mixture of blue and green.\n\nThis is OK, but it would be better if some aliens went faster than\nothers.\n\n\n', ' Randomise the glide time\n\nAt the moment, every alien clone takes exactly 3&nbsp;seconds to glide\ndown the screen.  We want to add a bit of variation, by making each\nalien clone take a random time to glide down the screen.  This will\nmake some aliens move faster than others and make it more interesting.\n\nThe `drift_down_screen()` code is where we\'ll need to make the change.\n\nWe have already done `import random`, so we can use the\n`random.uniform()` function to get a random number between 3.0 and 5.0\n(including fractions).  We\'ll store the randomly-chosen number in a\n*variable*:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, 3.0)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nAnd then use this variable instead of the fixed number `3.0` in the\n`glide_to_xy()` function call:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nJust like when we change `when_green_flag_clicked` into\n`when_I_receive("play-game")` earlier, the red and green lines here\nmean that you delete the old code (red background, with `-` at the\nleft), and add in its place the new code (green background, with `+`\nat the left).  Since most of the line is the same, you can just delete\n`3.0` and type in `glide_time` if you like.\n\nNow if you run the game, som aliens should be faster than others, and\nafter little while it looks almost like aliens are appearing at\nrandom.\n\n\n', " Click on the aliens!\n\nSo far our project is quite nice to look at, but it isn't a *game*\nbecause there's nothing for the player to do.  We'll fix that now.\n\n", ' Add sound effects\n\nWe want there to be sound effects when the player clicks on the alien.\nWe\'ll have one sound effect when they click on an enemy alien, and a\ndifferent one when they click on a friendly one.  This tutorial comes\nwith an explosion and a scream, and we tell the `Alien` sprite that we\nwant to use these sounds in a similar way to how we say what images we\nwant to use for costumes:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\n', ' React when hit\n\nWe want the Aliens (original and clones) to react when they\'re clicked\non by the player.  We\'ll write some `when_this_sprite_clicked` code\nwhich plays the right sound, depending on whether that clone is an\nenemy or a friendly alien.\n\nRemember that an alien is an enemy when wearing the blue costume\n(number&nbsp;0) and a friendly visitor when wearing the green costume\n(number&nbsp;1).  So we can use an `if`/`else` statement to test which\ncostume the alien is wearing, and play the right sound:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nIf you try now, you should hear the sounds when you click on the\naliens — check you get the right sound for the right costume!\n\nBut the player can keep clicking on the same alien.  We need the alien\nto hide itself once its been clicked on.  We can add a line to our\n`handle_hit()` code to make this happen:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nNow each alien should disappear (with a sound) when the player clicks\non it.  Try this!\n\nBut now we have a different problem — once the player has clicked on\nall six aliens, no more aliens appear.\n\n', ' Re-appear at the top of the screen\n\nWe need to make sure each alien is visible just before it starts\ngliding down the screen.  Add a line to the `drift_down_screen()` code\nto make this happen:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nTry your game!  It should be quite noisy now.\n\n', ' Make a sound if the player misses\n\nFor extra noise, we\'ll make it so that a sound effect happens if the\nplayer misses all the aliens when they click.  We can tell this\nhappens by making the *stage* react when it\'s clicked.\n\nFirst we need to say that the `Galaxy` stage will use the \'fizz\' sound\neffect (which comes with this tutorial):\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n\nAnd then we\'ll add some code to the `Galaxy` so it plays this sound\nwhen the player clicks on the stage:\n\nimport pytch\nimport random\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nTry your game!  It should be even more noisy.\n\n\n', " Keep score\n\nTo let the player know how they're doing, we'll add score-keeping to\nthe game.  Just like in Scratch, your program remembers numbers (or\nstrings, or lists, or anything else) using a *variable*.  In Python,\nyou don't have to explicitly make a variable.  Setting a new variable\nto a value creates that variable for you.\n\n", ' Initialise score to zero\n\nThe player\'s score starts off at zero, so near the top of the program,\nwe\'ll create the `score` variable with a value of `0`:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\n', ' Show score\n\nIn Scratch, you tick a box to say that you want the variable to be\nshown.  In Pytch you do this by writing some code.  We want the\n`score` variable to be shown as soon as the game starts, so the\n`run()` code inside `Galaxy` is a good place to put this.\n\nIn this tutorial, we won\'t go into the details of what `None` means.\nYou can see that we give the *name* of the variable that we want to\nshow:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\n', ' Give points for hitting an enemy\n\nLet\'s give the player 10&nbsp;points when they click on an enemy\ninvader.  We already have some code which makes a sound when the alien\nis clicked, so this is a good place to add the code which updates the\nscore.\n\nWe need to tell Python that it\'s the *global* variable `score` we want\nto change.  Without this, Python thinks you mean a *local* variable\nwhich exists just inside your `handle_hit()` code.  Once we\'ve said\nwhich `score` we\'re talking about, we add 10 to it.\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(30, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(90, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nTry this — you should get 10 points for every blue enemy you click on.\n\n', ' Avoid repetitive code\n\nThe changes we\'ll make in this chapter aren\'t essential for the game\nto work.  But they do tidy up your code and make it easier to change\nand work with.\n\nYou might have thought that the code we added, quite early on, to make\nthe five Alien clones was very repetitive:\n\n    self.go_to_xy(-150, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(-90, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(-30, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(30, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(90, 180)\n    pytch.create_clone_of(self)\n\nThere is a pattern to these pairs of lines of code, which we can make\nclearer by writing out exactly where those `-90`, `-30`, `30`,\nand `90` number come from.  The pattern is that we\'re adding an extra\n`60` each time, starting from `-150`.  We can change the code to show\nthis clearly:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 2 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 3 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 4 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nand then we can even make the `-150` and `-90` values fit the exact\npattern, by changing:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        self.go_to_xy(-150 + 0 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 1 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 2 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 3 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(-150 + 4 * 60, 180)\n        pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nNow your code should look like\n\n    self.go_to_xy(-150 + 0 * 60, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(-150 + 1 * 60, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(-150 + 2 * 60, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(-150 + 3 * 60, 180)\n    pytch.create_clone_of(self)\n    self.go_to_xy(-150 + 4 * 60, 180)\n    pytch.create_clone_of(self)\n\nand you can see that this is just five copies of\n\n    self.go_to_xy(-150 + SOME_NUMBER * 60, 180)\n    pytch.create_clone_of(self)\n\nwith a different number in place of `SOME_NUMBER` each time, starting\nat&nbsp;0 and going up to&nbsp;4.\n\nWe can use a *loop* to avoid all this copied code.  The *loop\nvariable* `i` will take on values starting at&nbsp;0, and stopping\njust before it gets to&nbsp;5.  This "stop just before 5" way of\nsaying when to stop is how Python does things — it seems strange at\nfirst but does make sense once you get used to it!\n\nThen inside the *loop body* we have the two lines, and use the\nvariable `i` where the repeated code has `0`, `1`, `2`, `3`, or `4`:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\n\n', " Count lives\n\nThe game is quite good now, but there's nothing to discourage the\nplayer from just clicking everywhere.  There's no penalty for hitting\na friendly alien.\n\nWe'll fix that by giving the player three lives, and making it so\ndestroying a friendly alien costs a life.\n\n", ' A \'custom block\'\n\nIn Scratch, you can create *custom blocks* to:\n\n* give a name to a particular bit of behaviour\n\n* let you re-use that behaviour without duplicating large stacks of\n  blocks.\n\nIn Python, you can do the same thing.  You *define* a function, and can\n*call* it from elsewhere in your code.  We\'ll do that to gather\ntogether the "lose a life" behaviour.\n\nWe\'ll copy the existing behaviour of making the *scream* sound, by\ndefining a function `lose_life()`.  To define a function in Python, we\nuse `def` — we\'ve been using this already in fact, to define the code\nwhich happens when, say, the sprite is clicked on.\n\nHere\'s the start of our new `lose_life()` function:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.start_sound("scream")\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nNow we have the function, but nobody is using it.  This is like the\nsituation in Scratch where you have made a custom block, but not used\nit anywhere.\n\nWe\'ll change the `handle_hit()` function to use our new function:\n\nimport pytch\nimport random\n\nscore = 0\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nTest this now — the game should work exactly as before.  (So you might\nwonder why we\'re making these changes.  As your projects get bigger,\nit becomes more important that a human can read and understand the\nprogram, and one way to make this easier is by giving names to parts\nof the behaviour.)\n\n', ' Keeping track of lives\n\nWe need a variable to store how many lives the player has.  The\nchanges are very similar to when we brought in the `score` variable.\nFirst we create the variable near the top of our program:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nThen we want the variable to be shown on the stage.  We don\'t want the\ndisplay to be right on top of where the score is, so we provide extra\ninformation saying that we want the right-hand edge of the display to\nbe a little bit in from the right-hand edge of the stage.  This is\nwhat the `right=236` code is doing here:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nAnd finally we then want to take one life away whenever the player\nclicks on a friendly alien.  We say we want to work with the *global*\n`lives` variable, and then subtract one from it:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n        global lives\n        lives -= 1\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nTry this now — you should see the `lives` display go down each time\nyou click on a green alien.  But the game doesn\'t stop when you run\nout of lives.  We\'ll fix this next.\n\n\n', ' End game when no lives left\n\nOur last piece of work is to make the game stop when the player has\nused all their lives.  We *could* just ask \'is `lives` zero?\' at\ndifferent places in the code, but it will be clearer to give a name to\nthis idea, with a `game_over` variable.  This will be either `True` or\n`False`, and when the game starts up, the game is *not* over, so we want:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\ngame_over = False\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n        global lives\n        lives -= 1\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\n', ' All lives gone means game is over\n\nThe only time that `game_over` might change is when the player has\nlost a life.  So, inside `lose_life()`, we\'ll ask whether subtracting\na life has left `lives` equal to zero.  If so, we update the global\n`game_over` variable to be `True`:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\ngame_over = False\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while True:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n        global lives\n        lives -= 1\n        if lives == 0:\n            global game_over\n            game_over = True\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\n', ' Stop the aliens when game is over\n\nWe now have to make sure no more aliens glide down the screen once the\ngame is over.  We\'ll change the `forever`-like loop inside\n`drift_down_screen()` so that each alien (clone or original) keeps\ngoing as long as the game is not over:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\ngame_over = False\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while not game_over:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n        global lives\n        lives -= 1\n        if lives == 0:\n            global game_over\n            game_over = True\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nTry this now — deliberately click on three green aliens.  You should\nsee that no more aliens appear, but any aliens which are part-way down\nthe screen keep going until they reach the bottom.  We\'ll tidy this\nlast part up now.\n\nWe want all aliens to disappear immediately the game is over.  We\'ll\nmake this happen with a message which `lose_life()` will broadcast\nafter setting `game_over` to `True`:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\ngame_over = False\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while not game_over:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n        global lives\n        lives -= 1\n        if lives == 0:\n            global game_over\n            game_over = True\n            pytch.broadcast("game-over")\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\nIf you try this now, nothing will happen because nobody is *listening*\nto this message.  We\'ll add a last piece of code to the `Alien` so\nthat all aliens (clones or the original) hide when they hear that\nmessage:\n\nimport pytch\nimport random\n\nscore = 0\nlives = 3\n\ngame_over = False\n\n\nclass Alien(pytch.Sprite):\n    Costumes = ["enemy-alien.png", "friendly-alien.png"]\n    Sounds = ["explosion.mp3", "scream.mp3"]\n\n    @pytch.when_I_receive("make-clones")\n    def make_clones(self):\n        for i in range(5):\n            self.go_to_xy(-150 + i * 60, 180)\n            pytch.create_clone_of(self)\n        self.go_to_xy(150, 180)\n\n    @pytch.when_I_receive("play-game")\n    def drift_down_screen(self):\n        while not game_over:\n            self.switch_costume(random.choice([0, 1]))\n            self.set_y(180)\n            self.show()\n            glide_time = random.uniform(3.0, 5.0)\n            self.glide_to_xy(self.x_position, -180, glide_time)\n\n    @pytch.when_this_sprite_clicked\n    def handle_hit(self):\n        if self.costume_number == 0:\n            self.start_sound("explosion")\n            global score\n            score += 10\n        else:\n            self.lose_life()\n        self.hide()\n\n    def lose_life(self):\n        self.start_sound("scream")\n        global lives\n        lives -= 1\n        if lives == 0:\n            global game_over\n            game_over = True\n            pytch.broadcast("game-over")\n\n    @pytch.when_I_receive("game-over")\n    def do_game_over(self):\n        self.hide()\n\n\nclass Galaxy(pytch.Stage):\n    Backdrops = ["starry-sky.jpg"]\n    Sounds = ["fizz.mp3"]\n\n    @pytch.when_green_flag_clicked\n    def run(self):\n        pytch.show_variable(None, "score")\n        pytch.show_variable(None, "lives", right=236)\n        pytch.broadcast_and_wait("make-clones")\n        pytch.broadcast("play-game")\n\n    @pytch.when_stage_clicked\n    def make_miss_sound(self):\n        self.start_sound("fizz")\n\n\n', ' Game complete!\n\nTest your game now and make sure it works properly.\n\n\n', " Challenges\n\nHere are some ways you could make the game even better:\n\n* Once the game is over, the player still hears the *fizz* noise if\n  they click on the stage.  Stop this from happening.\n\n* Make the aliens move more quickly as the player's score goes up.\n\n* Add a rare red alien which is worth 50 points.\n\n* Add some left-to-right randomness to where the aliens start.\n\n\n", ' Credits\n\nThis project was loosely inspired by the *Red Alert* game in the DK\nbook [*Coding Games in\nPython*](https://www.dk.com/us/book/9781465473615-coding-games-in-python/).\n\n', ' Detailed credits\n\n{{< asset-credits >}}\n', ' Hello there!\n\nIn this tutorial we will learn about how to create and run a Pytch project with a Sprite.\n\n---\n\n', ' Writing a Pytch program\n\nPytch programs are written in a programming language called Python, to\nwhich we have added extra commands for Sprites, sounds, and other\nthings. You make a Pytch project by writing a Python program using the\nspecial Pytch system.\n\nThe first line tells Python that we will be using the Pytch\nadd-ons. If you leave this out then you can only write ordinary Python\nprograms without Sprites, so the Pytch web site puts that line in for\nyou when you make a new project.\n\nWhen you see a block of code like this, with some lines of text shown\nin green with "+" symbols in front of them, it\'s telling you to change\nyour project so that it has the new lines in green added to it. Add\nthem in exactly the places where they are shown.\n\nimport pytch\n\n\n', ' Creating the Sprite\n\nWe\'ll start with the sprite that the player will control.\n\nTo create a new sprite we need to say three things: that we are\ncreating a new "thing" in the project, give the thing a name, and say\nthat it is a Sprite (rather than a Background or some other sort of\nthing). In Pytch we can do that by making a new "class" and giving it\na name.\n\nFor this example I\'ve chosen the name "Snake" but really you could\nname it nearly anything you like.\n\nNotice that the line ends with a ":" marker. There is more to come in\nthe definition of Snake, and this symbol is how we tell Pytch that\nthere will be more to the Snake class.\n\nimport pytch\n\nclass Snake(pytch.Sprite):\n\n\n', ' Adding a costume\n\nOnce we have created the new Sprite the next job is to say what it\nlooks like and how it behaves. In this tutorial we have already added\na picture for the snake costume to the project, so let\'s connect it to\nthe sprite.\n\nWe need to write a line that sets up a _variable_ in the new Sprite\nthat will hold a list of the costumes.\n\nPytch needs to find the list in a variable named `Costumes` (with a\ncapital `C`). If we call it anything else then Pytch won\'t be looking\nin the right place when it goes to find the costumes.\n\nThis variable contains a list of the images in the project that will\nbe used by this Sprite as costumes. In Python we create lists by\nwriting things between square brackets (`[` and `]` characters). When we\nmention the file name we need to put it between double-quote\ncharacters (these: `"`).\n\nFinally, so that the instruction is contained _within_ the Sprite —\nthat is, it\'s pushed in from the left of the program a bit. This is\nhow Python knows that this variable is part of the Sprite. Everything\nthat\'s part of the Sprite has to be "indented" (pushed in) the same\namount.\n\nSo, to create our `Costumes` variable we need a line like this.\n\nimport pytch\n\nclass Snake(pytch.Sprite):\n    Costumes = ["Snake.png"]\n\n\nIf you click the green flag now, you should see the Snake appear in\nthe middle of the stage.  Try it!\n\n', ' Adding a script\n\nThese lines add a new script (Python programmers sometimes calls these\n"functions" or "methods" instead of scripts) to the Sprite. The word\n"def" followed by the name of the function creates it, and the lines\nthat are indented more than the first line are the instructions that\nare contained within the script.\n\nimport pytch\n\nclass Snake(pytch.Sprite):\n    Costumes = ["Snake.png"]\n\n    def speak(self):\n        self.say_for_seconds("Hello there!", 2.0)\n\n\nNow, we haven\'t yet told Pytch when it should run this script. We need\nto attach a "hat" block to it, something that tells Pytch to run the\nscript at the right time. We can set this script to run when the Snake\nsprite is clicked on.\n\nimport pytch\n\nclass Snake(pytch.Sprite):\n    Costumes = ["Snake.png"]\n\n    @pytch.when_this_sprite_clicked\n    def speak(self):\n        self.say_for_seconds("Hello there!", 2.0)\n\n\n', ' Running the Project\n\nFinally, we can press the *green flag* and see the results of this\nwork! When you click the green flag, the Snake should appear on the\nstage, and when you click on it, a speech balloon will appear.\n\nCongratulations on your first Pytch project!\n\n', ' Challenges\n\nCan you change your program to complete these challenges?\n\n* Make the Snake say `"Hi there!"` instead of `"Hello there!"`.\n\n* Make the Snake\'s speech balloon appear for 3&nbsp;seconds instead of\n  2&nbsp;seconds.\n\n* (More advanced:) Make the Snake say two things, one after the other.\n  Maybe it could say `"Hi there!"` for two seconds, and then `"OK,\n  bye!"` for two seconds.\n\n\n', ' Credits\n\n{{< asset-credits >}}\n', ' Bunner: make a frogger-like game\n\nIn this tutorial we will make a complete\n[Frogger](https://en.wikipedia.org/wiki/Frogger)-style arcade game.\n\n\n---\n\n', ' Making the stage\n\nLet\'s start by getting a nice backdrop up. I\'ve drawn one already\n(using images from *Code The Classics* kindly made available by\nRaspberry Pi Trading Ltd), so we can just load the image.\n\nBegin by making a class to represent the stage. We can call it\nanything we want so long as it is declared as being a\n`pytch.Stage`. The second line of the class sets up a Python variable\nwith the list of background images that we can use (there\'s only one\nfor now but we will add more).\n\nEach background has a name that we\'ll use in our code when we want to\nswitch backgrounds. When we just give the filename of the image file\nthat we want to use Pytch will use that (without the `.png` extension)\nas the name of the costume.  You can see these files by clicking the\n*Images and sounds* tab, then click on the *Tutorial* tab to get back\nhere.\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nIf you run your project now, by clicking the green flag, you\'ll see\nour backdrop appear.\n\n', ' Create our hero\n\nThere is not much to do in our game yet, so let\'s add something for\nthe player to control.\n\nThe graphics are already there for the player\'s sprite; all we have to\ndo is create a class and set up the names of the costumes. Like the\nstage, the name of our new class is up to us, but we have to declare\nthat it\'s a kind of `pytch.Sprite`.\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n\nWhen green flag is clicked, we:\n\n* select the starting costume (in fact Pytch will start a Sprite off\n  wearing its first costume, but it\'s a good idea to be explicit about\n  this, in case you change the order of the `Costumes` list);\n\n* move the Bunny actor to the right place,\n\nlike this:\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n\nRun the project by clicking the green flag to check this works.\n\n', ' Moving our hero\n\nNow let\'s give the player a way to move the bunny around.\n\nWe will create a function that will move the bunny up the screen, and\ntell Pytch to run that function whenever the up arrow key is pressed\non the keyboard. We add a simple check of the bunny Y-coordinate to\nmake sure that it is never moved off the top of the screen.\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n\nIf you haven\'t already then this is a good place to run the project\nand make sure it\'s working. Press the up arrow a few times, and make\nsure that you\'re happy it works.\n\nOnce you are comfortable with it, you could add three more functions\nfor the other directions.  Remember, each function has to have its own\nname or Python will not recognise it properly.\n\nThis is my version:\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\n', ' Create the cars\n\nThe next step is to create some obstacles to make it harder to reach\nthe top of the screen. Our first obstacles are the cars that will\ntravel left and right in three lanes of traffic that the bunny will\nhave to cross. There is room for three lanes in the background, but\nwe\'ll design our solution so that we could easily add more lanes of\ntraffic if we want.\n\nSo that there is some variety in how they look I have chosen two\ndifferent images for each car, each of which could be driving left or\nright. Later on we will select at random the between the two different\nversions of cars driving to the left (or right, depending on the lane)\nfor each car.\n\nThe file names for these graphics don\'t describe which direction they\nshow the cars facing so I have told Pytch I\'d like to use my own\nlabels for the costumes (`left0`, `right0` and so on) instead of using\nthe file name.\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n\nThe original car is going to remain hidden, because we\'ll use *clones*\nfor the actual traffic. So we\'ll hide the original Car when the\nprogram starts:\n\nimport pytch\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n\n', ' Designing the traffic\n\nFor the next section of code I want to select the different costumes\nat random so that there is some variety. Python has some random\nnumber code available, we just need to *import* it so that it\'s\navailable\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n\n(This is very similar to how you "add an extension" in Scratch to\nmake more blocks available.)\n\nMy plan is to use the original `Car` sprite as a sort of\n*template*. Every time I want to add a new car to a lane of traffic\nI\'ll move the hidden Car sprite to the starting position for that lane\nand then make a clone of it. The clone will then show itself and drive\nacross the screen. In this way I can make as many moving car *objects*\nas I want from just one `Car` class.\n\nThe original `Car` sprite will have three scripts running, one for\neach lane, that will act as a kind of car factory, adding new cars\nwith a bit of randomness to keep the gaps between the cars\nunpredictable.\n\n', ' Making the first car factory script\n\nI\'ll start with the lane closest to the bottom of the screen. Once we\nhave this working we will be able to copy it to get the other lanes\nworking.\n\nAs soon as the green flag is clicked the Car sprite starts a loop to\nmanage the cars in the first lane of traffic. There\'s no need to have\nthe loop running as fast as possible — that would make far too many\ncars — so I put in a little delay using `wait_seconds` so that the\nloop only runs ten times a second.\n\nEach time the loop goes around I ask for a random number between 0 and\n1 (that\'s what `random.random()` does), and if it\'s below 0.2 then the\nCar sprite moves to just off the screen, left of the first lane, and\nmakes a clone at this position (so instead of making a clone every\ntime around the loop we make one *about* one time in five).\n\nI guessed at the timing of the delay, and at the frequency with which\ncars were created, and then ran the program a few times tinkering with\nthe numbers until I was happy with the number of cars created.\n\nOne final tweak I put in: because we might create another car in this\nlane the next time around we wait a little longer after creating the\nclone so that it has time to drive along the lane.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n\n', ' Controlling the clone\n\nWe want the clone to run its own script when it\'s created, so we will\nuse the `when_I_start_as_a_clone` event.  I will build up the loop\nthat drives the car from left-to-right along the lane. First, I want\nthe clone to choose a costume, either `"right0"` or `"right1"` (they\nare two different colours of cars, and it keeps the lane of traffic\nfrom looking too boring if there\'s a mix of costumes).\n\nPython has a handy `random.choice` function that will return one of\nthe items from the list we give it, randomly chosen.\n\nThe clone got its own copy of the `movement_direction` variable containing\nwhatever the Car sprite had in it at the moment the clone was\ncreated. It contains the string `"right"` (because that\'s what\n`StartTrafficRowOne` stored just before creating the clone), so\ncombining that with either \'0\' or \'1\' gets us one of the `Car` costume\nnames we set up earlier.  Also, the images are a bit big, so I\'ll\nshrink the clone to 65% of its original size.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n\n\nOnce the sprite has appeared we start a loop that drives the car to\nthe right.\n\nYou might wonder why I\'m are checking the \'movement_direction\' variable, since\nit has to contain \'right\'. The answer is that if we get this code\ncorrect for moving right we\'ll be able to use it for the left-moving\nlane as well.\n\nIn order to allow us to tweak how fast the lane of traffic moves I\'ll\nuse a variable to change how much it moves. That way if I wanted to\nspeed it up later on I can just change what\'s stored in the variable.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n\n\n\nThe speed variable needs to be set up somewhere, which I do at the\nstart of the `startTrafficRowOne` method.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n\n\n\nOnce the car has moved far enough to be off the right-hand side of the\nscreen I hide it and then delete the clone. Deleting the clone keeps\nthings tidy and means there are not lots of useless clones lying\naround just off the stage edge.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n\n\nNow, back to my idea of using the same code to control cars in the\nleft-hand lane. If the movement direction is not \'right\' then I suppose it must\nbe \'left\'. Those cars just move a _negative_ amount (and have moved\nfar enough once their `x`-coordinate has moved off the left edge of\nthe stage)\n\nI\'ll add the code to handle the \'left\' movement direction, and then move on to\nmaking actual clones that want to move that way.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n\n\n', ' Making the rest of the car factories\n\nOnce we have that we can add two more loops that start on green\nflag. They are modelled on the loop that creates `Car` clones for lane\n1, but they move to different x and y positions before cloning the\ncar.  I\'ll set the lanes of traffic to all move at the same speed for\nnow.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n\n\nThere\'s an important point to think about here. What if the row two\nloop moved the car, but before it got to set the `movement_direction` or create\nthe clone the row one loop ran a bit and altered the x and y position?\nWe could end up with a car that was positioned off to the left of the\nscreen, but which had its movement direction set to drive to the left, and it\nwould just vanish right away!\n\nIn fact, this can\'t happen, and it\'s worth knowing why. Pytch will\nonly allow another function to run at specific places. One of those\nplaces is at the end of a loop (another is when a function does\n`wait_seconds`). The manual has more information about this, but it\'s\nenough for now to know we are safe!\n\n', " Squish the bunny!\n\nYou'll notice that the cars don't actually present any sort of\nchallenge at the moment, because the bunny can just hop through the\nlanes without being touched. Time to fix that.\n\n", ' Checking for collisions\n\nChecking every time something moves will mean changes in lots of\nplaces in the code — I\'d need to check for the same thing when cars\nmove _and_ when the bunny moves. Instead I\'ll create a new script that\nruns in each `Car` clone constantly checking for collisions. Writing\n`while True` means the loop will run forever (actually, just until the\nclone is deleted when it reaches the end of the lane).\n\nThe loop that checks if the `Car` clone is touching the bunny might\nlook a little odd, since it just has a `pass` statement in it (`pass`\nis a Python instruction that does nothing). What we need here is a\nloop that waits until the clone is touching the `Bunny` sprite to move\non to the print. Python needs there to be a statement inside the loop,\nbut there isn\'t actually anything to do if they are not touching, we\njust want to loop around and check again until they are. This is the\nsort of thing `pass` is useful for.\n\nI\'ll decide later what to actually do when there is a collision. So I\ncan test my code I\'ll print out a message whenever there is a\ncollision.  To see these messages, click on the *Output* tab.  You can\ncome back to this tutorial by clicking on the *Tutorial* tab.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.touching(Bunny):\n                pass\n            print("Squish the bunny!")\n\n\n\nAs soon as I test this I find there is a problem (try it out now). The\ncar reports it\'s squishing a bunny when it drives past the bunny, even\nif it\'s not in the lane? What\'s going on?\n\nThe answer is in our costumes. The very nice costumes we\'re using\n(courtesy of the [Code The\nClassics](https://wireframe.raspberrypi.org/books/code-the-classics1)\nbook) are actually bigger than they look. Pytch checks for \'touching\'\nby checking whether rectangles drawn around the entire costume of each\nsprite overlap. The `Car` costume and the `Bunny` costume overlap when\nthe bunny is _next_ to the lane (you can see that the car costumes\nhave some shadows under them that stick out into the lane below. It\nlooks nice but it messes up how `touching` works).\n\nThe easiest thing to do is write a special bit of code to check\nwhether a clone is hitting another sprite. If we check that the `y`\ncoordinates are close together (say, within 10 pixels) and the `x`\ncoordinates are within 40 then it works pretty well. I got those\nnumbers by looking at the costume images, and a bit of trial-and-error.\n\nThis function works by comparing the coordinates of the clone (`self`)\nand some other sprite that we provide as input.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.touching(Bunny):\n                pass\n            print("Squish the bunny!")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nWhen Pytch sees me say `touching(Bunny)` it interprets it as "if this\nsprite is touching _any_ Bunny sprite", original _or_ clone.\n\nIn order to use this in place of `touching` we can\'t pass `Bunny`,\nbecause that\'s a sprite _class_. We need to supply the _instance_. The\nPytch `the_original` function lets us get the sprite from a sprite\nclass. (There is another function to get a list of all the clones,\nwhich we will see later.)\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            print("Squish the bunny!")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThis works much better at printing messages for the bunny and car\ncolliding, when I try it out I only see the "Squish the bunny!"\nmessage printed when the sprites actually _look_ like they are\noverlapping now.\n\nNow that this is working I\'d like to get the bunny to react to being\nsquished. This is really something for the `Bunny` sprite to take care\nof. I can send a message that something has happened using the\n`broadcast` system.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png"]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n', ' Responding to being squished\n\nBack in the `Bunny` sprite I want to add some costumes to show when\nthe bunny gets driven on. I\'m making sure the names of these match up\nwith the names of the "main" costumes so that I can easily pick the\nright one to show.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nTo respond to a broadcast, a Sprite uses `when_I_receive`.  When the\nbunny sprite sees the squishing broadcast I want to change to a\ncostume that matches the direction that the bunny was already\nfacing. I can look up the name of the current costume and then add\n"_squished" to get the name of a new costume.\n\nimport pytch\n\nimport random\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        self.switch_costume(self.costume_name + "_squished")\n        pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThere\'s still a problem, though. The car clone broadcasts \'squish\nbunny\' and we change costume... but then a moment later the car sprite\nruns its hit checking again and broadcasts squish _again_, and we run\nthrough this code again (choosing a costume like\n`"up_squished_squished"`). That\'s a problem!  If you try it, and get\nsquished, you\'ll see an error pop up in the *Errors* tab.  You can\ncome back to this tutorial by clicking on the *Tutorial* tab.\n\nTo fix it I\'ll introduce a way for the bunny to know that it has\nalready acted on the message (I\'ll have other uses for this idea\nsoon).\n\n', ' Setting modes for the player\n\nI\'ll create a set of three variables to describe three "states" the\nbunny could be in:\n\n* Waiting for the game to start\n* Letting the player control it\n* Sitting squished on the road\n\nThe bunny reacts differently to some broadcasts depending on what\nstate it\'s in (for example, when it\'s sitting squished it doesn\'t want\nto get squished _again_ while a car drives over it, that would cost\nanother life!)\n\nI just want these variables so that I have three _names_ I can use for\nthese states, because it\'ll make my program easier to read. A neat\nPython trick to set up a set of variables so that they have different\nvalues looks like this:\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        self.switch_costume(self.costume_name + "_squished")\n        pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThis sets `WAITING` to be zero, `PLAYING` to be 1, and so on.\n\nLater on I plan to add a title screen (and the bunny will start out\nwaiting), but for now the bunny starts out playing.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        self.switch_costume(self.costume_name + "_squished")\n        pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nNow I can set up the squishing code so that the bunny won\'t squish\n_again_ if it\'s already showing as squished. I just move the actual\ncostume-change code inside a test:\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        self.switch_costume("up")\n        if self.y_position < 150:\n            self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        self.switch_costume("right")\n        if self.x_position < 210:\n            self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        self.switch_costume("down")\n        if self.y_position > -150:\n            self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        self.switch_costume("left")\n        if self.x_position > -210:\n            self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nYou might not have tried this, but if you press the arrow keys when\nthe bunny is squished on the road the moving functions still run (of\ncourse they do, we didn\'t do anything to switch them off). That\'s not\ngreat!\n\nNow that the bunny knows when it\'s supposed to be letting the player\nplay and when it\'s supposed to be squished, we can add a check to each\nof the moving routines to skip through them if the bunny isn\'t\nsupposed to move.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nOnce we have done that the game seems to be over once the bunny is\nsquished. The next step is to give the player a number of lives and\nlet the game end and restart.\n\n', ' End and restart the game when the bunny is squished\n\nI\'m going to rearrange the code in the Bunny sprite so that it will be\neasier to reset the game when the player loses all their lives. The\nfirst step is to split out the things that we want to do at the start\nof the game from the things that we do every time we play one\nlife. Right now they are all mixed together in\n`go_to_starting_position` which runs when the green flag is clicked.\n\nSo I\'ll make a new function, `start_game`, that has the stuff we want\nto run at the start of each game. At first this is the same as the\nstuff we do on green flag.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nI will switch the bunny from visible to invisible when the green flag\nis clicked (this is paving the way for a splash screen at the start of\nthe game)\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nNow I have a use for the `WAITING` mode we created recently. Before\nthe game actually begins the bunny is neither squished nor playing.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nNow I can add a use of this setup function to the code that handled\nthe bunny being squished. We pause for a while to let the player see\nthe costume of the squished bunny, and then reset the game.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.start_game()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThe `start_game` function is run by Pytch when the green flag is\nclicked, but I can _also_ run it whenever I want by using its name.\n\nIt doesn\'t affect what I\'m doing here, but it\'s worth pointing out the\ndifference between running `start_game` from the green flag event and\nrunning it by using its name. The second way doesn\'t run `start_game`\n*alongside* `squish`, so if there was another statement in `squish` it\nwouldn\'t run until `start_game` had finished.\n\n', ' Adding a life counter\n\nRestarting the game after the bunny has been squished once is a bit\nunfair, it would be better to give the player a few attempts (say, the\ntraditional three lives).\n\nAt the start of the game I\'ll set a new variable in the bunny sprite\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.start_game()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nIn the initialization for the bunny I\'ll set this to a number that\nsuggests the game hasn\'t started yet (it\'ll be set to something else\nwhen the bunny is ready to play).\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.start_game()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nEach time the bunny gets squished I\'ll reduce that counter by one.\n\nMoving some code around again, I want to separate the idea of\n_starting the game_ from the idea of _playing a life_. So I\'ll create\na new function that has the code relevant to playing a life (moving\nback to the start row and selecting a costume).\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    def play_one_life(self):\n        self.lives = self.lives - 1\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.start_game()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nI can run this function in the `start_game` routine\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.play_one_life()\n\n    def play_one_life(self):\n        self.lives = self.lives - 1\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.start_game()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nAnd I can also call it when the bunny is squished:\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.play_one_life()\n\n    def play_one_life(self):\n        self.lives = self.lives - 1\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = PLAYING\n        self.show()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n', ' Running out of lives\n\nThe next thing I want to do is end the game when the player has used\nup all their lives. That means that after the player is asked to play\na life I\'ll check whether it\'s actually possible to do that. If there\naren\'t then the bunny will go into its "waiting" state until a new\ngame starts, and we\'ll announce to all the other sprites and clones\nthat the game has ended.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nWhen the clone cars see that the game has ended I want them all to\nvanish (even if they haven\'t reached the edge of the canvas yet). When\na clone is deleted all of its running scripts stop so everything is\ncleaned up for the clones that are driving.\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThe original `Car` sprite is still running its traffic factory\nscripts, of course, and they will just create more cars unless they\nare stopped.\n\nAlthough the original `Car` sprite will receive the game over\nbroadcast and run the `vanish` script that won\'t stop the car\nfactories. The original sprite is immune to `delete_this_clone`\nactions (because it\'s not a clone!). So I\'ll have to do something else\nto stop those scripts.\n\nOne way to handle this would be to change the loop in those factory\nscripts so that instead of running forever they only ran as long as\nthe game was playing. Something like this:\n\nimport pytch\n\nimport random\n\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nTo make this work I add a new global variable. I could try to use the\nbunny state for this, but the question of whether the bunny can be\nmoved is different to whether the game is playing or not so I decided\nto track them separately.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        self.lives = 3\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThe bunny notes that the game is running by setting this variable to\n`True`.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nWhen the bunny runs out of lives it notes that the game should be over\nby setting this variable to false (I could have chosen to set this to\nfalse in a function that is run when the "game over" broadcast is\nreceived, that would work too)\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nNow I can make the same changes I made to the first factory script to\nthe other two so that every row or traffic is stopped when the game\nends:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        self.speed = 3\n        while True:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nAnd:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nOnce all of the traffic has been stopped and the clones have vanished\nI decided to add a new backdrop with a game over message —\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n— and switch to showing it:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n', ' The start button\n\nWhen the game is over I would like a way to start it again. This is\nwhere the rearranging of code I did earlier on will pay off.\n\nThe plan is to change things around so that starting to play a game\nand clicking the green flag are separate things. The green flag will\nstart off the whole project, and playing a game is something the\nproject manages for itself.\n\nFirst I make a new sprite that will act as a \'start game\' button that\nappears when the green flag is clicked, and when the game ends (so\nthat you can use it to start the game over).\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n\nI want it to react to being clicked with the mouse.  When it\'s clicked\nit announces to the rest of the project that it\'s time to start a new\ngame, then the button hides itself.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_green_flag_clicked\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nThe bunny should start a new game when this message is received, not\nwhen the green flag is clicked\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_green_flag_clicked\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nThe traffic factories should also begin making cars when the game\nstarts, not when the green flag is clicked.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nWhen the game starts the stage needs to switch to the world costume\n(it might have been showing the \'game over\' screen)\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nNow we have a whole game that can be started by the player, runs\nthrough the player\'s 3 lives, ends, and can be started again, without\nhaving to restart the whole project using the green flag!\n\n', ' Keeping score\n\nWe should be showing the lives remaining somewhere on the stage, but\nbefore we get to that we can add another small but important feature.\n\nMost games are more fun if there\'s a way to keep track of how well the\nplayer is doing. I\'m going to introduce a score that increases as the\nplayer heads up the screen.\n\nFirst I\'ll add a new global variable to track the score (I\'m using a\nglobal variable because there are going to be several parts of the\nproject that will access the score, but I could have made it a\nvariable in the Bunny sprite and used `Bunny.the_original` to access\nit from other parts of the project)\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running\n        self.lives = 3\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nThe score starts at zero at the start of the game\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nWe could let the player earn a point every time they manage to move up\nthe stage towards the goal at the top.  For now we\'ll put in a\n`print()` statement so we can see what\'s going on in the *Output*\npanel:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                score = score + 1\n                print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nWhat I don\'t like about this is that if the player just taps \'up\' then\n\'down\' then \'up\' they get two points. They could run up a very high\nscore just hopping from the start onto the first row of traffic and\nthen back down again and never really making any progress.\n\nOne way to handle this would be to lower the score when the player\nmoves downwards, but I don\'t like making the score go down.\n\nSo I decided that I would change it so that they only earn a point if\nthey are making progress up the stage. I created a variable to keep\ntrack of how high up the stage the bunny is, and another to count the\nhighest row the bunny has reached.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                score = score + 1\n                print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nThese both start at zero when playing a life:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                score = score + 1\n                print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nEvery time the bunny moves up the stage I add one to the current row\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                score = score + 1\n                print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nAnd lower it when the bunny moves down\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                score = score + 1\n                print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nEvery time we move up I check if this is a new \'highest ever reached\'\nrow. If it is then the player gets a point (but I also remember that\nthe highest rows reached has gone up, so the player has to go even\nfurther up the stage to get another point).\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nNow we have a way to count score, it would be nice to display it on\nthe stage instead of just printing it.\n\n', ' Showing score\n\nTo show the score I\'m going to create two new sprites that will be\nused to show the digits of the score (I\'ll only track scores up to 99)\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n\nThere are ten costumes, which I want to name "digit-0" to\n"digit-9". Instead of typing each of the ten costumes out by hand I\ndecided to use a Python shortcut for making lists with this kind of\npattern. There are two parts to this:\n\nThe first is writing a `range` statement inside the list definition.\nWriting a bit of Python like: `[ n for n in range(10) ]` creates the\nlist `[0,2,3,4,5,6,7,8,9]` (`n` in this is just a temporary variable\nthat is created for setting up the list only). So I can use this to\nmake the "varying" part of each costume\'s name.\n\nThe second trick is that we can fill in "placeholders" in a string\nusing Python\'s special "f-strings" (formatted string literals). The\nbasic idea of these is that you write a string that mentions some\nvariables in it, within curly braces and Python will fill in the value\nof the variable.\n\nFor example, if you write `f"digit-{n}"` when the variable `n` has the\nnumber `3` in it then the final string would be `"digit-3"`. The `f`\nin front of the first double-quote is what tells Python that it should\nlook for variables marked by curly braces inside the string.\n\nWe can combine this with a range loop to get several strings that\nfollow some pattern.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n\nWhen the score changes I\'ll get the bunny sprite to send out a\nbroadcast message. When this score sprite receives that it will look\nup the score, calculate the _units digit_ of the score, and set the\ncostume to the corresponding digit. I use the f-string trick in this\nto select the right costume name based on the "units" value of the\nscore.\n\nCalculating the units digit is easy. We divide the score by ten and\n_take the remainder_. This is what the Python `%` operator does.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    print( "Score is ", score )\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\n\nI get the bunny to announce score changes using a broadcast:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\n\nTo show the \'tens\' digit of the score I make a second sprite that\'s\nalmost identical. The only differences are where on the screen it\nappears, and the calculation done in `show_correct_digit`, where I use\nthe `//` operator (which divides a number and throws away any decimal\npart).\n\nNotice in this class that I was able to re-use the `score_costumes`\nvariable, which I had made as a global variable.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\n', ' More status displays\n\nNow that we have a way to show some digits we could also use this to\nshow the number of lives remaining. A third sprite that has the same\ncostumes and which updates whenever the lives change can do this.  The\nnumber of lives is always less than 10, so we don\'t have to do the\n\'divide and take remainder\' trick this time:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\n\nI also add a \'lives changed\' broadcast to tell this when to update.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\n\nWhy not just update this when we see the \'bunny squished\' message,\nwhich is what causes the lives to change? Because the very next thing\nin this tutorial is to add a new way for the bunny to lose a life!\n\n', ' Adding the water hazard\n\nThe final obstacle to add to the game is the water hazard. At the\nmoment once the bunny has passed the three lanes of traffic all it has\nto do is make its way to the top of the screen to reach the goal.\n\nI\'m going to add a new check that makes the bunny drown (and lose a\nlife) if it\'s on the water. But first I want to add some way to get\nacross the water!\n\nBased on the same design as the `Car` sprite, I make a `Log` sprite:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n\nI could copy the `Car` factory approach exactly, but I want to show\nhow to reduce the amount of code a little. So I create a function for\na "log factory" that takes the movement direction and the y-coordinate\nof the lane. I called the input variable to the function\n`chosen_direction` because it\'s the direction that whoever starts this\nlog with has chosen for it. This is the factory:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n\nThen I start three separate factory scripts, each providing different\ninputs to the factory. This will get me three different factory\nscripts running, all based on the same `start_row` code:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n\nEach `Log` clone drives along the lane just as the cars do. But\ninstead of checking to see if they have "squished" a bunny they check\nto see if the bunny is standing on the clone. If it is then the bunny\nis carried along with the log.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n\nJust as with the `Car` we will remove the clone logs when the game ends\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n\nAnd just like the `Car` we need to have a special collision detection\nfunction (otherwise the slightly-too-large sprite costumes will detect\ncollisions at times that don\'t really look good to the player)\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED = range(3)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n', ' Drowning in the water\n\nNow we are ready to make the water hazardous. I\'ll add a new mode for\nthe bunny. Just like when the bunny is squished, I don\'t want the\nmovement keys to work while the bunny is drowning.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png" ]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThere is a set of seven costumes showing different frames of a\nsplash. I want to add all of them. To avoid having to write out the\nnames of them all I use the same trick I used in making the digit\ncostumes, and then add that list of new costumes onto the end of the\nbunny\'s costume list:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nWhen the game is running the bunny will regularly scan to see if it\'s\nin the water section of the canvas (that\'s checked using the `y`\ncoordinate). If it is then unless it\'s touching one of the `Log`\nclones it starts drowning.\n\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching(Log)\n            ):\n                self.mode = DROWNING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nNow, there are two things to fix here.\n\nThe first is easy, we need to make sure that we run this and\n`start_playing` in the correct order. They both run when a `start\nplaying` message is received, but we can\'t be sure which of them runs\nfirst, and if `watch_for_water` were to run first then `start_playing`\nwould not have had a chance to set the `game_running` variable yet.\n\nIf that happens then the loop in `watch_for_water` could end before\nthe `game_playing` gets set, and the bunny wouldn\'t be checking if it\nshould drown.\n\nWe can fix that easily, because we made sure that `start_playing` sets\n`game_running` before it sets the bunny mode. So we just do an extra\nloop that will stall for a while if `start_playing` hasn\'t set things\nup yet.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching(Log)\n            ):\n                self.mode = DROWNING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThis code is not quite right, because I\'m using the `touching` routine\nand as we know it\'s possible for the bunny to be on a row below or\nabove a log and stil register as touching it. We really want to use\nthe custom `hits` routine, in the same way as we did for the `Car`\nclones.\n\nBut the logs have the opposite effect to the cars; instead of killing\nthe bunny (by squishing) they keep it alive (not drowning).\n\nI\'m going to make a custom version of the `touching` routine that\ndeals with this. The plan is to get a list containing all the clones,\nand then check them one-by-one to see if the the bunny is touching\nthem.\n\nThis uses `all_clones`, the counterpart to the `the_original` function\nwe used back when we wanted to access the Bunny sprite. I use the\nPython `for` loop to check each one in turn, using my `hits`\nfunction. If `hits` ever returns `True` to say that that particular\nlog has hit the bunny then I return from the `touching_any_log`\nfunction immediately. I can\'t return `False` until I have checked\n_every_ log, of course, because even if the first log we check returns\n`False` for the hit checking one we check later in the list might\nstill return `True`.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching(Log)\n            ):\n                self.mode = DROWNING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nNow in the original `watch_for_water` function I can replace the\nbuilt-in `touching` with a call to my custom `touching_any_log`.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nThere\'s one final tweak to this hit check, though. When we were\ntalking about the traffic started I said that we didn\'t have to worry\nabout two pieces of code that were running at the same time\ninterfering, because they would only give way to each other at\nspecific places, like at the end of a loop.\n\nThis is a problem for us now — in `touching_any_log` it could happen\nthat the code checks the first couple of logs in the list, and then\nthe code that moves the first log gets to run and moves the log a bit\nso that it\'s under the bunny. Then `touching_any_log` gets to run some\nmore, but it has already moved past that first log in it\'s\nchecking. The result would be that our hit check says the bunny isn\'t\ntouching a log (so we decide the bunny is drowning), but to the player\nit looks like the bunny was under the log.\n\nThis can\'t normally happen because the built in Pytch `touching`\nfunction doesn\'t let anything else run while it\'s checking to see if\nyou touch anything. We can tell Pytch that we want it to treat our\nfunction the same way. We can add a special kind of "hat block" to a\nfunction that orders this (you can have this along with a normal hat\nblock, just list one after the other).\n\nPytch will still let other code run if this function takes too long\nabout getting through its loops (about a second, by default). That\nwill be just fine for us.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nOnce we have determined that the bunny is drowning we play the frames\nof the \'splash\' animation one after the other:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nWe pause for a moment to let the player gather themselves:\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nand play another life\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n                self.play_one_life()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if self.hits(Bunny.the_original()):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nFinally, if you try this you might find that while the animation is\nplaying a log comes along and seems to "push" the splash animation\nalong. That\'s because the log is pushing the bunny sprite with it! I\nadd a simple check to the code that handles this so that the bunny is\nonly moved if it is really sitting on the log, and not if it\'s already\nunder water.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n                self.play_one_life()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n\n', ' Finishing the level\n\nThe final part of the game is to give the player a reward for reaching\nthe goal at the top of the screen. Every time we move up to a new\nhighest row I\'ll check to see whether that was the top of the screen\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n                self.play_one_life()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n                    self.check_victory()\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nIf it is then I run a loop that moves the bunny through facing its\nfour directions (so that it looks like it\'s dancing).\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING = range(4)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n                self.play_one_life()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n                    self.check_victory()\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n    def check_victory(self):\n        global score\n        if self.y_position > 159:\n            self.mode = DANCING\n            for _ in range(4):\n                for facing in ["right", "down", "left", "up"]:\n                    self.switch_costume(facing)\n                    pytch.wait_seconds(0.125)\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nI added a new `DANCING` mode as well so that the bunny isn\'t `PLAYING`\n(I don\'t want the player to be able to move the bunny during the\nvictory dance and it felt wrong to pretend the bunny was in a\n`SQUISHED` or `WAITING` mode )\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING, DANCING = range(5)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n                self.play_one_life()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n                    self.check_victory()\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n    def check_victory(self):\n        global score\n        if self.y_position > 159:\n            self.mode = DANCING\n            for _ in range(4):\n                for facing in ["right", "down", "left", "up"]:\n                    self.switch_costume(facing)\n                    pytch.wait_seconds(0.125)\n                    score = score + 1\n                    pytch.broadcast("score changed")\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nOnce the dance is complete the bunny moves back to the bottom of the\nstage and the level starts again.\n\nimport pytch\n\nimport random\n\n\ngame_running = False\n\nscore = 0\n\nWAITING, PLAYING, SQUISHED, DROWNING, DANCING = range(5)\n\n\nclass BunnyStage(pytch.Stage):\n    Backdrops = ["world.png", "gameover.png"]\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        self.switch_backdrop("world")\n\n    @pytch.when_I_receive("game over")\n    def game_over(self):\n        self.switch_backdrop("gameover")\n\n\nclass Bunny(pytch.Sprite):\n    Costumes = [ "up.png", "right.png", "down.png", "left.png",\n                 "up_squished.png", "right_squished.png",\n                 "down_squished.png", "left_squished.png",\n    ] + [f"splash-{n}.png" for n in range(8)]\n\n    @pytch.when_green_flag_clicked\n    def go_to_starting_position(self):\n        self.switch_costume("up")\n        self.go_to_xy(0, -160)\n        self.mode = WAITING\n        self.hide()\n        self.lives = -1\n        self.highest_row_reached = 0\n        self.current_row = 0\n\n    @pytch.when_I_receive("start playing")\n    def start_game(self):\n        global game_running, score\n        self.lives = 3\n        score = 0\n        game_running = True\n        self.play_one_life()\n\n    def play_one_life(self):\n        if self.lives > 0:\n            self.lives = self.lives - 1\n            pytch.broadcast("lives changed")\n            self.switch_costume("up")\n            self.go_to_xy(0, -160)\n            self.highest_row_reached = 0\n            self.current_row = 0\n            self.mode = PLAYING\n            self.show()\n        else:\n            global game_running\n            game_running = False\n            pytch.broadcast("game over")\n            self.hide()\n            self.mode = WAITING\n\n    @pytch.non_yielding_loops\n    def touching_any_log(self):\n        for log in Log.all_clones():\n            if log.hits(self):\n                return True\n        return False\n\n    @pytch.when_I_receive("start playing")\n    def watch_for_water(self):\n        while self.mode != PLAYING:\n            pass\n        while game_running:\n            if (\n                self.y_position > 30\n                and self.y_position < 160\n                and not self.touching_any_log()\n            ):\n                self.mode = DROWNING\n                for i in range(8):\n                    self.switch_costume(f"splash-{i}")\n                    pytch.wait_seconds(0.1)\n                pytch.wait_seconds(0.5)\n                self.play_one_life()\n\n    @pytch.when_key_pressed("ArrowUp")\n    def move_up(self):\n        global score\n        if self.mode == PLAYING:\n            self.switch_costume("up")\n            if self.y_position < 150:\n                self.change_y(40)\n                self.current_row = self.current_row + 1\n                if self.current_row > self.highest_row_reached:\n                    self.highest_row_reached = self.current_row\n                    score = score + 1\n                    pytch.broadcast("score changed")\n                    self.check_victory()\n\n    @pytch.when_key_pressed("ArrowRight")\n    def move_right(self):\n        if self.mode == PLAYING:\n            self.switch_costume("right")\n            if self.x_position < 210:\n                self.change_x(25)\n\n    @pytch.when_key_pressed("ArrowDown")\n    def move_down(self):\n        if self.mode == PLAYING:\n            self.switch_costume("down")\n            if self.y_position > -150:\n                self.change_y(-40)\n                self.current_row = self.current_row - 1\n\n    @pytch.when_key_pressed("ArrowLeft")\n    def move_left(self):\n        if self.mode == PLAYING:\n            self.switch_costume("left")\n            if self.x_position > -210:\n                self.change_x(-25)\n\n    @pytch.when_I_receive("squish bunny")\n    def squish(self):\n        if self.mode != SQUISHED:\n            self.mode = SQUISHED\n            self.switch_costume(self.costume_name + "_squished")\n            pytch.wait_seconds(0.5)\n            self.play_one_life()\n\n    def check_victory(self):\n        global score\n        if self.y_position > 159:\n            self.mode = DANCING\n            for _ in range(4):\n                for facing in ["right", "down", "left", "up"]:\n                    self.switch_costume(facing)\n                    pytch.wait_seconds(0.125)\n                    score = score + 1\n                    pytch.broadcast("score changed")\n            self.go_to_xy(0, -160)\n            self.current_row = 0\n            self.highest_row_reached = 0\n            self.mode = PLAYING\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\n        ("left0", "car00.png"),\n        ("right0", "car01.png"),\n        ("left1", "car20.png"),\n        ("right1", "car21.png"),\n    ]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowOne(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -125)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowTwo(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(285, -80)\n                self.movement_direction = "left"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_receive("start playing")\n    def startTrafficRowThree(self):\n        global game_running\n        self.speed = 3\n        while game_running:\n            if random.random() < 0.2:\n                self.go_to_xy(-285, -30)\n                self.movement_direction = "right"\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def drive(self):\n        self.switch_costume(self.movement_direction + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "right":\n            while self.x_position < 285:\n                self.change_x(self.speed)\n        else:  # Direction should be "left"\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_start_as_a_clone\n    def check_for_collision(self):\n        while True:\n            while not self.hits(Bunny.the_original()):\n                pass\n            pytch.broadcast("squish bunny")\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\nclass StartButton(pytch.Sprite):\n    Costumes = ["start.png"]\n\n    @pytch.when_green_flag_clicked\n    def start(self):\n        self.go_to_xy(0, 120)\n\n    @pytch.when_I_receive("game over")\n    def game_over_try_again(self):\n        pytch.wait_seconds(1)\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def start_new_game(self):\n        pytch.broadcast("start playing")\n        self.hide()\n\n\nscore_costumes = [(f"digit-{n}.png", 14, 14) for n in range(10)]\n\n\nclass Score_1(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(200, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_units = score % 10\n        self.switch_costume(f"digit-{score_units}")\n        self.show()\n\n\nclass Score_2(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(175, 162)\n        self.hide()\n\n    @pytch.when_I_receive("score changed")\n    def show_correct_digit(self):\n        score_tens = score // 10\n        self.switch_costume(f"digit-{score_tens}")\n        self.show()\n\n\nclass LivesCounter(pytch.Sprite):\n    Costumes = score_costumes\n\n    @pytch.when_green_flag_clicked\n    def set_position_and_size(self):\n        self.go_to_xy(20, 162)\n        self.hide()\n\n    @pytch.when_I_receive("lives changed")\n    def show_correct_digit(self):\n        life_number = Bunny.the_original().lives\n        self.switch_costume(f"digit-{life_number}")\n        self.show()\n\n\nclass Log(pytch.Sprite):\n    Costumes = ["log0.png", "log1.png"]\n\n    @pytch.when_green_flag_clicked\n    def start_hidden(self):\n        self.hide()\n\n    @pytch.when_I_receive("start playing")\n    def start_row_1(self):\n        self.start_row("right", 30)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_2(self):\n        self.start_row("left", 80)\n\n    @pytch.when_I_receive("start playing")\n    def start_row_3(self):\n        self.start_row("right", 130)\n\n    def start_row(self, chosen_direction, y):\n        self.speed = 3\n        if chosen_direction == "right":\n            x = -285\n        else:\n            x = 285\n\n        while game_running:\n            if random.random() < 0.05:\n                self.go_to_xy(x, y)\n                self.movement_direction = chosen_direction\n                pytch.create_clone_of(self)\n                pytch.wait_seconds(0.3)\n            pytch.wait_seconds(0.1)\n\n    @pytch.when_I_start_as_a_clone\n    def start_log(self):\n        self.switch_costume("log" + random.choice(["0", "1"]))\n        self.set_size(0.65)\n        self.show()\n        if self.movement_direction == "left":\n            while self.x_position > -285:\n                self.change_x(-self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(-self.speed)\n        else:  # Right\n            while self.x_position < 285:\n                self.change_x(self.speed)\n                if (\n                    self.hits(Bunny.the_original())\n                    and Bunny.the_original().mode != DROWNING\n                ):\n                    Bunny.the_original().change_x(self.speed)\n        self.hide()\n        self.delete_this_clone()\n\n    @pytch.when_I_receive("game over")\n    def vanish(self):\n        self.delete_this_clone()  # Does nothing on the non-clone original\n\n    def hits(self, other):\n        return (\n            abs(self.y_position - other.y_position) <= 10\n            and abs(self.x_position - other.x_position) <= 40\n        )\n\n\n\n', ' Challenges\n\nYou have reached the end of this tutorial, but there\'s lots more that\nyou could do with this project. Here are some ideas:\n\n* Make the game more challenging for the player. Add a broadcast that\n  goes out when the player reaches the goal. This broadcast could tell\n  the logs and cars that this was a new round, and use that to have\n  them move faster, or have more cars and fewer logs appear by\n  adjusting the numbers in the car and log factories.\n\n* Improve the accuracy of the `hits` routines (the log one,\n  especially, is a bit over-sensitive, it\'s easy for the bunny to fall\n  off the smaller logs without it looking like it should have)\n\n* Add some different types of obstacles (longer cars, using a lorry\n  costume, for example)\n\n* Vary the speed of the logs and cars in different lanes (you probably\n  don\'t want to vary the speed within a lane unless you can account\n  for the possibility of cars or logs hitting each other!)\n\n* It\'s easy to dodge over the road at the start of the game because\n  all the cars drive in from the edges but the bunny starts in the\n  middle. Have the car factories create some cars in the middle of the\n  road at the start of the game so that there isn\'t a time when the\n  roads are totally clear.\n\n* At the moment the bunny sprite is drawn so that it appears _under_ a\n  car when it\'s squished, but on top of the logs when it jumps onto\n  them. But we didn\'t do anything special to make that happen, it\'s\n  just how it worked out, and you might have noticed that it looks\n  wrong if the we\'re drawing the bunny drowning animation and a log\n  passes over it (the "splash" animation draws on top of the\n  log!). You can fix this by using the Pytch _layers_ to move the\n  bunny under and over other sprites as needed (use\n  `self.go_to_front_layer()` and `self.go_to_back_layer()`). Fix\n  this drawing problem by moving the bunny back and forward through\n  the layers.\n\n\n', ' Credits\n\nMany thanks to the Raspberry Pi Press for making the contents of their\n*Code The Classics* book available under a Creative Commons licence.  We\nhave used their code for inspiration, and also the images and sounds.\n\n{{< asset-credits >}}\n', ' Catch the apple!\n\nThis tutorial will show you how to make a simple game in Pytch.  The\nplayer will move a basket to try to catch apples which fall down the\nstage.\n\n![Screenshot](screenshot-w240-darker-bg.png', "img-center)\n\nWe'll develop the game in stages, showing how knowledge of Scratch\nhelps with understanding how things work in Python.\n\n\n---\n\n", ' Add a _Sprite_ for the player\'s bowl\n\nWe\'ll start with the Bowl which the player controls.  Just like in\nScratch, we make a _Sprite_.  In Pytch, we create a Sprite by adding\ncode to our program.\n\nYou need to make the following change to your program.  Clicking on\nthe blue "`?`" will show some help about understanding the changes\nyou need to make.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n\n\nYou will get an error if you try to run this now — then click back to\nthis _Tutorial_ tab.  The problem is that we haven\'t said anything at\nall about the _Bowl_.  We\'ll do that now, by saying what the bowl\nshould look like.\n\n', ' Add a costume for the Sprite\n\nPytch sprites have _costumes_ just like Scratch sprites do.  This\ntutorial comes with the images you need — you can see them in the\n_Images and sounds_ tab, then come back here by choosing the\n_Tutorial_ tab.  To add a costume to our Pytch sprite, we just need to\nwrite code saying which image to use.  A Sprite has a special variable\ncalled `Costumes` which tells Pytch about that Sprite\'s costumes.\n\nBecause a Sprite can have more than one costume, we give Pytch a\n_list_ of the costumes we want to use, even if there\'s only one\ncostume in that list.  Python writes lists with square brackets, like\nthis:\n\n```\n["red", "blue", "green"]\n```\n\nThe costume we want to use is called `"bowl.png"`, so we make a list\nwith just that in it:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n\nNow, if you click the green flag, you should see the player\'s bowl\nappear in the middle of the stage.  Test that now!\n\n\n', ' Start the bowl in the right place\n\nThe player needs to be able to move the bowl.  We\'ll let them do this\nwith the keyboard, using the `a` and `d` keys.  In Scratch, we would\ndo this by adding a script to our Sprite, clicking the blocks\ntogether.  In Pytch, we write code to do the same job.\n\nThe Pytch equivalent of adding a script is _defining a method_ in our\nSprite.  Our method will start off by moving the bowl to the correct\nplace on the stage.  A Python method needs a name, which should\nbriefly describe what it does.  We\'ll use `move_with_keys` for our\nmethod\'s name.\n\nPytch uses the same way of describing positions on the stage as\nScratch does, so we\'ll start off by making our method just move the\nbowl to a sensible place at the bottom of the stage.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n\nIn Scratch, you give a block the information it needs by filling in\nthe ‘holes’ in the block:\n\n```scratch\ngo to x: [0] y: [-145]\n```\n\nIn Python, you provide these extra pieces of information (called\n“arguments”) in brackets “`()`” after the method name:\n\n```\nself.go_to_xy(0, -145)\n```\n\nThe "`self.`" part at the start means we want the Sprite to do\nsomething.  The `x`-coordinate of `0` puts the bowl in the middle,\nleft-to-right.  I picked `-145` for the `y`-coordinate by trial and\nerror.\n\nIf you click the green flag now, our new code does not run.  This is because\nwhat we\'ve done so far is like making a script in Scratch with _no hat\nblock_ on top.  In Scratch we would attach a _when green flag clicked_\nhat block on top of our script.  In Pytch, we do something very\nsimilar, by attaching a special marker to the top of the method:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n\nNow if you click the green flag, the bowl should\nmove to its starting position at the bottom of the stage.\n\n\n', ' Let the player move the bowl\n\nNow we\'re going to let the player move the bowl.  We\'ll start by\nletting them move it to the right.  We\'ll keep checking whether the\nplayer is pressing the `d` key, and if so, change the bowl\'s\n`x`-coordinate.  In Scratch we would do this with a _forever_ block.\nPython has the `while True` statement to do the same job.\n\nIn Scratch, the blocks we want to run forever are _inside_ the\n_forever_ block.  In Python, the code we want to run forever is\n_indented_ to the right.\n\nPython\'s _if_ statements work in the same way.  The code you want to\nrun only if the condition is true is indented to the right.\n\nPutting this all together, we get this new code:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("d"):\n                self.change_x(2)\n\n\nIf you try this, it should let you move the bowl right by holding down\nthe `d` key.  But!  You can move the bowl all the way off the stage.\nWe\'ll fix that next.\n\n', ' Keep the bowl on the stage\n\nIf the player is pressing `d`, we then need to check whether it\'s OK\nto move the bowl right.  We do this be checking the bowl\'s\n`x`-coordinate.  When the bowl is as far to the right as possible, the\n`x`-coordinate is `190` — I found this value by trial and error in the\ncode below.  It\'s OK to move right as long as the `x`-coordinate is\nless than or equal to 190.  We add a test for this, and only do the\n`self.change_x(2)` if the test passes.\n\nMaybe you can guess what the red line, marked with “`-`”, means — if\nnot, you can click on the blue “`?`” to get an explanation.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nTest this now — click the green flag, then check you\ncan still move right, but only as far as the edge of the stage.\n\n', ' Let the player move left too\n\nThe same idea will let the player move _left_ as well.  We\'ll add code\nto the same `while True` loop.  The differences for moving left\ninstead of right are:\n\n* We check for the `"a"` key not the `"d"` key.\n* We check that the bowl is not too far left already, by checking that\n  its `x`-coordinate is at least `-145`.  (I\'ve left a bit of room at\n  the very left for a score-keeper to stand — we\'ll come to the\n  score-keeper later in the tutorial.)\n* We move by using a negative value for the amount the bowl should\n  change its `x`-coordinate by.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\n\n', ' Add a Sprite for the apple\n\nWe now need something for the player to catch.  We\'ll create another\nSprite for this, and we\'ll start by adding a line of code to define\nour new _Apple_ Sprite:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n\n\nBefore we can run this code, we need to put some code into the Apple\nSprite — we\'ll say what costume we want the Apple to have.  We\'re\ntaking the same steps here as what we did when we made the player\'s\nbowl sprite.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n\nIf you run the project now, an apple should appear in the middle of\nthe Stage.\n\n\n', ' Make the apple fall down the stage\n\nTo give the Apple its behaviour, we define a method — remember this is\nlike making a script in Scratch.  Because this is very similar to what\nwe did with the Bowl, we\'ll add this code all in one go.  We will:\n\n* Say that we want this code to run when the green flag is clicked —\n  this is like the \'hat block\' in Scratch.\n* Give the method a short name to say what it does — we\'re using\n  `move_down_stage`.  The code doesn\'t yet move the apple down the\n  stage but it will!\n* Start the code off with a line which moves the Apple to a good\n  starting point on the stage — I chose just off the top of the\n  stage, and off-centre to the right a bit.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n\n\nIf you try this now (click green flag), you should just be able\nto see the bottom of the apple at the top of the stage.\n\n', ' Actually move down the stage\n\nWhat we want the apple to do is keep moving down, as long as it is\nabove the bottom of the stage.  In Scratch we could use a `repeat\nuntil` block.  Python has a `while` statement instead.  This is very\nlike Scratch\'s `repeat until` block, but uses the test \'the other way\nround\' —\n\n* Scratch\'s `repeat until` block keeps running the contained blocks,\n  and _stops when the test is true_.\n* Python\'s `while` statement checks the test, and _runs the contained\n  code while the test is true_.\n\nWe want to test whether the apple\'s `y`-coordinate is higher than some\nvalue near the bottom of the stage.  By trial and error, I found that\n`-140` worked well for this.  We\'ll add this `while` loop to our\nmethod:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n\n\nWe\'re changing the `y`-coordinate by the negative number `-3` to make\nthe apple move _down_ the stage a small amount each time round the\n`while` loop.\n\nIf you run this code, the apple should fall down the stage, and stop\nat the bottom.\n\nThe `while` here might look different to when we used `while True` to\nmean "forever", but it\'s really just different ways of using the same\nthing.  When we want something to happen forever, the `True` in `while\nTrue` acts as a test which always passes, so the indented code keeps\nrunning again and again forever.\n\n\n', ' Catch the apple in the bowl\n\nFinally, we want to let the player catch the apple.  Each time the\napple moves, it can check whether it\'s been caught.  This happens if\nthe apple is touching the player\'s bowl.  If it is, then we want to\nhide the apple.  What we want to do is the Pytch equivalent of the\nScratch script\n\n```scratch\nif < touching (Bowl v)?> then\nhide\n```\n\nIn Pytch, the code we need is:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\n\n', ' Add the score-keeper\n\nThe next piece we want to work on is a score-keeper.  By now we know\nhow this works.  We define a new Sprite:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n\n\nGive it a costume:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n\nAnd make it move to a sensible place when the green flag is clicked.\nI found these coordinates by trial and error, to put the score-keeper\nin the bottom left corner of the stage.\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n\n\n\n', ' Start off with zero points\n\nWhen the player starts the game, they have no points.  We define a new\n_variable_ within the score-keeper.  This is just like when you make a\nnew _For this sprite only_ variable in Scratch.  In Python, you can\njust set a variable to a value, and this creates the variable.  We set\nthe starting value of a new `score` variable to zero:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n\n\nThe “`self.`” is what makes this variable like Scratch’s _For this\nsprite only_.\n\nThe job of the score-keeper is to announce the score, so we add a line\nto say the value of the `score` variable:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n\nIf you run this now, the score-keeper should say "`0`".\n\n\n', ' Give a point for catching an apple\n\nThe player can catch the apple in the bowl, but the score stays as\nzero.  We will fix this next.\n\nWe\'ll define another method in the `ScoreKeeper` sprite.  That\nmethod\'s job is to give the player a point and announce the new score.\nA good short name for this job is `award_point`, so we define a method\nwith this name.  The first piece of code in our new method will\nincrease the `score` variable by `1`:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    def award_point(self):\n        self.score += 1\n\n\nThe `+=` is like Scratch’s `change (score) by (1)`.\n\nAnd then we need to change what the score-keeper is saying to be the\nnew value of the `score` variable:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\nOur code is correct, but we haven\'t said when to run it.  We want to\nrun this method whenever the apple lands in the bowl.  In our code,\nit\'s the Apple\'s job to check whether it\'s landed in the bowl.  So,\njust like in Scratch, we\'re going to make the Apple _broadcast a\nmessage_ when it knows that it\'s landed in the bowl.  We\'ll tell Pytch\nto run our score-keeper\'s `award_point` method when it *receives* that\nmessage.\n\nJust like in Scratch, we have to choose a good message.  In Pytch, a\nmessage can be any string — we\'ll use `"award-point"`.\n\nThis is just like in Scratch, where we would use a `broadcast` block:\n\n```scratch\nbroadcast (award-point v)\n```\n\nand a `when I receive` hat-block:\n\n```scratch\nwhen I receive [award-point v]\n```\n\nAnd just like in Scratch, we have to choose a good message.  In Pytch,\na message can be any string — we\'ll use `"award-point"`.\n\nFirst we tell Pytch to run `award_point` whenever the score-keeper\nreceives the message `"award-point"`:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\nAnd then we make the apple broadcast this message when it\'s caught.\n\nThis change needs to be made inside your `Apple` sprite:\n\nimport pytch\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\nIf you try this now, you should be able to get your score from zero to\none by catching the apple.\n\n\n', ' Drop the apple from a random place\n\nSo far the game drops the apple in the same place every time you play.\nThis makes the game far too easy.  We want to make the apple drop in a\nrandom place each time.\n\nTo do this, we will use some code which other people have already\nwritten.  The name for a collection of Python code ready for use in\nother programs is _module_.  A module for making random choices comes\nwith Python — this module is called `random`.  We say we want to use\nthe `random` module in our program by _importing_ it:\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\n(This is how we’ve been using the `pytch` functions like\n`pytch.broadcast()` already.  When we `import` Python code like this,\nwe\'re doing something very similar to "adding an extension" in Scratch\nto make more blocks available.)\n\nNow we can use the function in the `random` module which picks a\nrandom whole number.  This is called `randint` (for _random integer_).\nWe need to say what the smallest and largest whole number allowed are.\nBy trial and error, I worked out:\n\n* The smallest (leftmost) `x`-coordinate which makes sure the apple\n  doesn\'t hit the score-keeper is `-145`.\n* The largest (rightmost) `x`-coordinate which makes sure the apple\n  isn\'t off the right edge of the stage is `190`.\n\nSo these are the values we give to the `random.randint` function, and\nwe set a new variable `drop_x` to the result.  In Scratch, this whole\nthing would look like\n\n```scratch\nset [drop_x v] to (pick random [-145] to [190])\n```\n\nand in Python it looks like this:\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(100, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\nNow we need to use the value of our `drop_x` variable instead of the\nfixed `100` for the `x`-coordinate of where the apple falls from:\n\nWe’re changing a line of code here — the blue “`?`” button will help\nexplain the “`-`” and “`+`” lines.\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(drop_x, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\nOne thing you might notice is that we didn\'t say `self.drop_x` here,\nwe just said `drop_x`.  By not saying `self`, Python makes the\n`drop_x` variable only exist inside the `move_down_stage` method.\nSince we won\'t need `drop_x` anywhere else, this way avoids cluttering\nup our code with variables.\n\nNow the game is better — each time click the green flag, the\napple falls from a different place.\n\n\n', ' Make apples keep falling\n\nWe\'re going to change the game so that the score-keeper is in charge\nof making the apple fall from the sky.  We\'re going to take away the\n\'hat block\' `@pytch.when_green_flag_clicked` on the Apple\'s\n`move_down_stage` method, and replace it with a hat block listening\nfor the broadcast of the message `"drop-apple"`:\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_I_receive("drop-apple")\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(drop_x, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n\nRight now, the game won\'t work, because nothing is broadcasting the\n`"drop-apple"` message.  We\'ll give that job to the score-keeper\nnow.\n\nWe\'ll make a new method in the ScoreKeeper sprite which will keep\ndropping apples.  A good name for this is `drop_apples`, so we\nstart defining that method:\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_I_receive("drop-apple")\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(drop_x, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n    def drop_apples(self):\n\n\nWe want to keep making apples drop from the top of the stage forever.\nJust like in the code which lets the player move the bowl, we do this\nwith a `while True:` loop in Python.  Inside that loop, we want to\nkeep broadcasting `"drop-apple"`.  But here, we will use the\n`broadcast_and_wait` function, because we don\'t want to drop the next\nApple until the current one has either been caught or reached the\nbottom of the stage.  In Scratch, the code would be\n\n```scratch\nforever\nbroadcast (drop-apple v) and wait\n```\n\nand in Pytch it\'s\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_I_receive("drop-apple")\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(drop_x, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n    def drop_apples(self):\n        while True:\n            pytch.broadcast_and_wait("drop-apple")\n\n\nFinally, we need to say that we want this to start happening when the\ngreen flag is clicked:\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_I_receive("drop-apple")\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(drop_x, 200)\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n    @pytch.when_green_flag_clicked\n    def drop_apples(self):\n        while True:\n            pytch.broadcast_and_wait("drop-apple")\n\n\nIf you try the game now, it doesn\'t work!  What\'s happening is that\nwe\'ve told the Apple to `hide` itself when it\'s caught, but we haven\'t\ntold it to `show` itself when it starts dropping.  We can fix that:\n\nimport pytch\nimport random\n\n\nclass Bowl(pytch.Sprite):\n    Costumes = ["bowl.png"]\n\n    @pytch.when_green_flag_clicked\n    def move_with_keys(self):\n        self.go_to_xy(0, -145)\n\n        while True:\n            if pytch.key_pressed("a"):\n                if self.x_position >= -145:\n                    self.change_x(-2)\n            if pytch.key_pressed("d"):\n                if self.x_position <= 190:\n                    self.change_x(2)\n\n\nclass Apple(pytch.Sprite):\n    Costumes = ["apple.png"]\n\n    @pytch.when_I_receive("drop-apple")\n    def move_down_stage(self):\n        drop_x = random.randint(-145, 190)\n        self.go_to_xy(drop_x, 200)\n        self.show()\n        while self.y_position > -140:\n            self.change_y(-3)\n            if self.touching(Bowl):\n                self.hide()\n                pytch.broadcast("award-point")\n\n\nclass ScoreKeeper(pytch.Sprite):\n    Costumes = ["Dani.png"]\n\n    @pytch.when_green_flag_clicked\n    def initialise(self):\n        self.go_to_xy(-215, -115)\n        self.score = 0\n        self.say(self.score)\n\n    @pytch.when_I_receive("award-point")\n    def award_point(self):\n        self.score += 1\n        self.say(self.score)\n\n    @pytch.when_green_flag_clicked\n    def drop_apples(self):\n        while True:\n            pytch.broadcast_and_wait("drop-apple")\n\n\nand this is now a playable game written in Python — congratulations!\n\n\n', ' Improve the game\n\nHere are some ideas on how you could make this game more fun:\n\n* Add a pause between one apple being caught / missed and the next one\n  appearing.  Use the help sidebar to find the Pytch version of\n  Scratch’s `wait () seconds` block.  (Hint: just after doing\n  `pytch.broadcast_and_wait("drop-apple")` is a good place to pause.)\n\n* The `x`-coordinate where the apple starts is already random.  Make\n  the starting `y`-coordinate be random too.  If an apple starts lower\n  down the stage, the player has less time to get the bowl under the\n  apple, making the game more challenging.\n\n* Play a sound when the player catches an apple.  There is an\n  apple-crunching sound as part of this tutorial.  Make this sound\n  part of the `Apple` sprite, by setting a `Sounds` variable just\n  under the `Costumes` variable: `Sounds = ["apple-crunch.wav"]`.  Use\n  the slide-out help panel to find the Pytch function for playing the\n  sound.\n\n* Change how quickly the player can move the bowl.  A bit quicker\n  would make the game easier; a bit slower would make the game harder.\n  The speed appears in two places: for moving left and for moving\n  right.  Investigate whether it’s worth setting a variable to hold\n  the speed.  A variable makes it easier to experiment with the\n  player\'s speed, but it is a bit more work to write the code in the\n  first place.\n\n* Add the provided `orange.png` costume to the Apple.  Its `Costumes`\n  list will then have two things in it.  (Your code will be clearer if\n  you also change the name of the sprite to `Fruit`!)  Each time the\n  `Fruit` appears, choose randomly which costume to wear.  (Hint: a\n  good place for this code is in the first part of the\n  `move_down_stage()` method, before the `while` loop.)  The slide-out\n  help panel will tell you the Pytch version of Scratch’s `switch\n  costume` block.\n\n* Make the referee jump up and down in celebration when the player\n  catches an apple.  In Scratch you might use the `repeat` block.  Use\n  the slide-out help panel to find how to do this in Pytch.\n\n* Make there be a fixed number of apples — maybe 8.  Advanced: At the\n  end of the game, make the referee say something like "You got 5 out\n  of 8".  You can use "f-strings" ([read about them in the Python\n  documentation](https://docs.python.org/3/tutorial/inputoutput.html', 'tut-f-strings))\n  to get the scorekeeper to say this.\n\n\n', ' Credits\n\nWe have used various freely-available resources to make this project:\n\n{{< asset-credits >}}\n', 'import pytch\nfrom math import pi, cos, sin\nimport random\n\n# Inspired by \"Recreate Pang\u2019s sprite spawning mechanic\"\n# in Wireframe 10 (https://wireframe.raspberrypi.org/issues/10)\n\n\nclass Orb(pytch.Sprite):\n    Costumes = [\"shinyorb.png\"]\n    Size_by_generation = [1.0, 0.7, 0.5, 0.35, 0.25]\n\n    @pytch.when_green_flag_clicked\n    def init(self):\n        self.generation = 0\n        self.go_to_xy(0, 120)\n        self.drift_down()\n\n    @pytch.when_this_sprite_clicked\n    def split(self):\n        for i in range(15):\n            self.set_size(self.size * 0.8)\n        self.generation += 1\n        if self.generation < len(self.Size_by_generation):\n            self.split_dir = -1\n            pytch.create_clone_of(self)\n            self.split_dir = +1\n            pytch.create_clone_of(self)\n        self.hide()\n\n    @pytch.when_I_start_as_a_clone\n    def separate_and_shrink(self):\n        self.set_size(self.Size_by_generation[self.generation])\n        self.change_x(self.split_dir * 80 * self.size)\n        self.change_y(random.random() * 80 * self.size)\n        self.drift_down()\n\n    def drift_down(self):\n        t = random.random() * 2.0 * pi\n        speed = 0.15 + 0.1 * random.random()\n        while True:\n            self.change_y(-speed + 0.15 * self.size * sin(2 * t))\n            self.change_x(0.25 * self.size * cos(t))\n            t += 0.025\n\n\nclass Sky(pytch.Stage):\n    Backdrops = [\"starry-sky.jpg\"]\n\n\n# Image credits:\n#\n# shinyorb.png\n#   https://openclipart.org/detail/3806/shiny-orb\n#   Image by OpenClipArt user \"noonespillow\"\n#   Placed into the public domain by creator\n#\n# starry-sky.jpg\n#   https://unsplash.com/photos/LUpDjlJv4_c\n#   Photo by Andy Holmes (https://unsplash.com/@andyjh07)\n#   Excerpt taken and darkened\n#   Used under the Unsplash License\n', 'import pytch\nimport math\nimport random\n\nn_cars = 11\n\n\nclass Track(pytch.Stage):\n    Backdrops = [\"racetrack.png\"]\n\n\nclass Car(pytch.Sprite):\n    Costumes = [\"blue-car.png\", \"red-car.png\"]\n\n    def prepare_step(self):\n        if random.random() < 0.0025:\n            self.wanted_speed = 0.5 + random.random() * 1.0\n        next_theta = Car.all_cars[self.next_idx].theta\n        max_speed = (next_theta - 15 - self.theta) % 360\n        actual_speed = min(self.wanted_speed, max_speed)\n        self.wanted_theta = self.theta + actual_speed\n\n    def act_step(self):\n        self.theta = self.wanted_theta\n        if self.theta >= 360:\n            self.theta -= 360\n        self.set_pose()\n\n    def set_pose(self):\n        # Our theta is our position on the track in DEGREES\n        th = self.theta_sense * self.theta\n        x = self.radius * math.cos(math.pi * th / 180.0)\n        y = self.radius * math.sin(math.pi * th / 180.0)\n        r = self.theta_sense * (self.theta + 90)\n        self.go_to_xy(x, y)\n        self.point_degrees(r)\n\n    @pytch.non_yielding_loops\n    def step(self):\n        for c in Car.all_cars:\n            c.prepare_step()\n        for c in Car.all_cars:\n            c.act_step()\n\n    @pytch.when_green_flag_clicked\n    def create_cars(self):\n        self.wanted_speed = 1.0\n        self.theta_sense = 1\n        self.radius = 135.5\n        for i in range(n_cars):\n            self.next_idx = (i + 1) % n_cars\n            self.theta = 360 * i / n_cars\n            pytch.create_clone_of(self)\n        self.radius = 155.5\n        self.theta_sense = -1\n        self.next_costume()\n        for i in range(n_cars):\n            self.next_idx = n_cars + (i + 1) % n_cars\n            self.theta = 360 * i / n_cars\n            pytch.create_clone_of(self)\n        self.hide()\n        Car.all_cars = Car.all_clones()\n        while True:\n            self.step()\n', 'import pytch\nimport random\n\nisland_stride = 76\n\n# See end for sound credits.\n\n\nclass Background(pytch.Sprite):\n    Costumes = [\"background-square.png\"]\n\n    @pytch.when_green_flag_clicked\n    def randomise_layout(self):\n        islands = [\n            (colour, number)\n            for colour in \"ABCD\"\n            for number in [1, 2, 3, 4]\n        ]\n        random.shuffle(islands)\n        State.island_order = islands\n        pytch.broadcast_and_wait(\"arrange-islands\")\n\n\ndef coords_of_index(idx):\n    row, col = divmod(idx, 4)\n    x = (col - 1.5) * island_stride\n    y = (row - 1.5) * island_stride\n    return (x, y)\n\n\nclass State(pytch.Sprite):\n    Costumes = []\n    Sounds = [\"buzzer.mp3\"]\n\n    # Will be created on green-flag by Background:\n    island_order = []\n    islands_clicked = []\n\n    @pytch.when_I_receive(\"find-route\")\n    @pytch.non_yielding_loops\n    def find_route(self):\n        hops = [[] for _ in State.island_order]\n\n        # Find hops within rows:\n        for row_idx in range(4):\n            for col_0 in range(4):\n                idx_0 = row_idx * 4 + col_0\n                kind_0 = State.island_order[idx_0]\n                for col_1 in range(col_0 + 1, 4):\n                    idx_1 = row_idx * 4 + col_1\n                    kind_1 = State.island_order[idx_1]\n                    if kind_0[0] == kind_1[0] or kind_0[1] == kind_1[1]:\n                        hops[idx_0].append(idx_1)\n                        hops[idx_1].append(idx_0)\n\n        # Find hops within columns:\n        for col_idx in range(4):\n            for row_0 in range(4):\n                idx_0 = row_0 * 4 + col_idx\n                kind_0 = State.island_order[idx_0]\n                for row_1 in range(row_0 + 1, 4):\n                    idx_1 = row_1 * 4 + col_idx\n                    kind_1 = State.island_order[idx_1]\n                    if kind_0[0] == kind_1[0] or kind_0[1] == kind_1[1]:\n                        hops[idx_0].append(idx_1)\n                        hops[idx_1].append(idx_0)\n\n        # Find shortest paths from source node, stopping\n        # if we hit destination node.\n        start = State.islands_clicked[0]\n        goal = State.islands_clicked[1]\n        seen = {start}\n        previous_island = [None for i in State.island_order]\n        print(seen)\n        queue = [start]\n        while len(queue) > 0:\n            island = queue.pop(0)\n            if island == goal:\n                break\n            for next_island in hops[island]:\n                if next_island not in seen:\n                    previous_island[next_island] = island\n                    seen.add(next_island)\n                    queue.append(next_island)\n        if previous_island[goal] is None:\n            self.play_sound_until_done(\"buzzer\")\n        else:\n            route = [goal]\n            island = goal\n            while previous_island[island] is not None:\n                island = previous_island[island]\n                route.insert(0, island)\n            print(route)\n            State.route = route\n            pytch.broadcast(\"show-route\")\n\n\nclass Island(pytch.Sprite):\n    Costumes = [\n        f\"circle-{colour}-{number}.png\"\n        for colour in \"ABCD\"\n        for number in [1, 2, 3, 4]\n    ]\n    Sounds = [\"pop.mp3\"]\n    start_shown = False\n\n    @pytch.when_I_receive(\"arrange-islands\")\n    def arrange_islands(self):\n        for idx, kind in enumerate(State.island_order):\n            self.idx = idx\n            self.kind = kind\n            pytch.create_clone_of(self)\n\n    @pytch.when_I_start_as_a_clone\n    def go_to_position(self):\n        x, y = coords_of_index(self.idx)\n        self.go_to_xy(x, y)\n        self.switch_costume(f\"circle-{self.kind[0]}-{self.kind[1]}\")\n        self.show()\n\n    @pytch.when_this_sprite_clicked\n    def note_click(self):\n        n_already_clicked = len(State.islands_clicked)\n\n        self.start_sound(\"pop\")\n        if n_already_clicked == 0:\n            print(\"start\", self.idx, self.kind)\n            State.islands_clicked.append(self.idx)\n            pytch.broadcast_and_wait(\"highlight-start\")\n        elif n_already_clicked == 1:\n            print(\"goal\", self.idx, self.kind)\n            State.islands_clicked.append(self.idx)\n            pytch.broadcast_and_wait(\"highlight-end\")\n            pytch.broadcast(\"find-route\")\n        elif n_already_clicked == 2:\n            pytch.broadcast_and_wait(\"reset-highlights\")\n            State.islands_clicked.pop(0)\n            pytch.broadcast_and_wait(\"highlight-start\")\n            State.islands_clicked.append(self.idx)\n            pytch.broadcast_and_wait(\"highlight-end\")\n            pytch.broadcast(\"find-route\")\n\n\nclass Highlight(pytch.Sprite):\n    Costumes = [\"light-highlight.png\", \"dark-highlight.png\"]\n    Sounds = [\"whoosh-slow.mp3\"]\n    start_shown = False\n\n    def highlight(self, position_idx, costume_tag):\n        x, y = coords_of_index(position_idx)\n        self.go_to_xy(x, y)\n        self.switch_costume(f\"{costume_tag}-highlight\")\n        self.show()\n\n    @pytch.when_I_receive(\"highlight-start\")\n    def highlight_start(self):\n        self.is_start = True\n        self.highlight(State.islands_clicked[0], \"light\")\n\n    @pytch.when_I_receive(\"highlight-end\")\n    def make_end_highlight(self):\n        pytch.create_clone_of(self)\n\n    @pytch.when_I_start_as_a_clone\n    def hightlight_end(self):\n        self.is_start = False\n        self.highlight(State.islands_clicked[1], \"dark\")\n\n    @pytch.when_I_receive(\"show-route\")\n    def show_route(self):\n        if not self.is_start:\n            return\n        for idx in State.route[1:]:\n            self.start_sound(\"whoosh-slow\")\n            x, y = coords_of_index(idx)\n            self.glide_to_xy(x, y, 0.6, \"ease-in-out\")\n            pytch.wait_seconds(0.15)\n\n    @pytch.when_I_receive(\"reset-highlights\")\n    def reset_highlights(self):\n        self.hide()\n        self.delete_this_clone()\n\n\n# Sound credits:\n#\n# buzzer.mp3\n#   https://freesound.org/people/Breviceps/sounds/493163/\n#   Here we use just the first section\n#   Used under CC0 (public domain)\n#\n# whoosh-slow.mp3\n#   https://freesound.org/people/qubodup/sounds/60013/\n#   Modified by slowing down and inserting leading silence\n#   Used under CC0 (public domain)\n#\n# pop.mp3\n#   https://freesound.org/people/Vilkas_Sound/sounds/463388/\n#   By freesound user \"Vilkas_Sound\"\n#   Used under CC-BY-3.0 (https://creativecommons.org/licenses/by/3.0/)\n']